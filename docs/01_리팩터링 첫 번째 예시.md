# Chapter 01. 리팩터링: 첫 번째 예시

> 🌱 1장에서는 리팩터링 예시를 보고, 그 과정을 따라가면서 리팩터링을 전반적으로 어떻게 수행하는지 감을 잡아본다. 실습을 진행하며 주요 내용과 문장을 아래에 정리하였다.

<br />

## 1.2 예시 프로그램을 본 소감

+ 책에서는 '공연료 청구서 출력 프로그램' 예제로 1장을 진행한다.
+ 코드를 수정하려면 사람이 개입되고, 사람은 코드의 미적 상태에 민감하다. **설계가 나쁜 시스템은 수정하기 어렵다.** 원하는 동작을 수행하도록 하기 위해 수정해야 할 부분을 찾고, 기존 코드와 잘 맞물려 작동하게 할 방법을 강구하기 어렵기 때문이다. 수정할 부분을 찾기 어려우므로 실수와 버그가 생길 가능성도 높아진다.

> 💡 프로그램이 새로운 기능을 추가하기에 편한 구조가 아니라면, 먼저 **기능을 추가하기 쉬운 형태로 리팩터링하고 나서, 원하는 기능을 추가**한다.

<br />

## 1.3 리팩터링의 첫 단계

+ 리팩터링의 첫 단계는 리팩터링 영역을 꼼꼼하게 검사해 줄 테스트 코드를 마련하는 것이다. 리팩터링 기법들이 버그 발생 가능성을 최소화하도록 구성됐다고 하나, 실제 작업은 사람이 하므로 언제든 실수할 수 있다.
+ 성공/실패를 스스로 판단하는 자가 진단 테스트를 만든다. 그렇지 않으면 노트에 적어둔 값을 일일이 비교해야 하고, 속도가 상당히 떨어진다. 자가 진단 테스트를 작성하고 실행하는데 필요한 모든 기능을 제공하는 최신 테스트 프레임워크를 사용하자. 테스트를 작성하는 데 시간이 걸리지만, 디버깅 시간이 줄어 전체 작업 시간은 오히려 단축된다.

> 💡 **리팩터링 하기 전에 제대로 된  테스트부터 마련**한다. **테스트는 반드시 자가 진단**하도록 만든다.

<br />

## 1.4 statement() 함수 쪼개기

+ 워드 커닝햄이 말하길, 코드를 분석해서 얻은 정보를 휘발성이 높기로 악명 높은 저장장치인 내 머릿 속에 기록되므로, 재빨리 코드에 반영해야 한다.

<br />

### **함수 추출하기**

  + 가장 먼저 유효범위를 벗어나는 변수, 즉 새 함수에서는 곧바로 사용할 수 없는 변수가 있는지 확인한다. 함수 안에서 해당 변수들의 값이 변경되는지 확인한다. 
    + 값을 변경하지 않는 경우, 매개 변수로 함수에 전달한다.
    + 값이 변하는 경우, 해당 변수 값을 초기화하는 코드를 함수에 포함시키거나, 변수의 값을 반환하는 등의 작업이 필요하다.

  + 함수 추출 후에는 코드를 들여다보며 지금보다 명확하게 표현할 수 있는지 검토한다. 변수, 인수의 이름 ... 을 더 명확하게 바꿔보자. 좋은 코드라면 하는 일이 명확히 드러나야하며, 이때 변수 이름은 큰 역할을 한다.

    > 💡 컴퓨터가 이해하는 코드는 바보도 작성할 수 있다. **사람이 이해하도록 작성하는 프로그래머가 진정한 실력자**다.

+ 수정 후에는 곧바로 컴파일하고, 테스트해서 실수가 없는지 확인한다. **조금씩 변경하고 매번 테스트하는 것은 리팩터링 절차의 핵심이다.** 한 번에 너무 많이 수정하려다 실수를 저지르면 디버깅하기 어려워 결과적으로 작업 시간이 늘어난다.

  > 💡 **리팩터링은 프로그램 수정을 작은 단계로 나눠 진행**한다. 그래서 중간에 실수하더라도 버그를 쉽게 찾을 수 있다.

+ 수정사항을 테스트해보고 문제가 없다면, 다음 단계로 변경사항을 로컬 버전 관리 시스템에 커밋한다. 하나의 리팩터링을 문제없이 끝낼 때 마다 커밋해두면, 중간에 문제가 생기더라도 이전의 정상 상태로 쉽게 돌아갈 수 있다. 자잘한 변경들이 어느 정도 의미있는 단위로 뭉쳐지면 공유 저장소로 푸시한다.

<br />

### **변수 제거하기**

  + **변수 인라인하기**
    + **임시 변수가 함수를 호출**하고, 그 변수**값이 다시 바뀌지 않는 경우, 함수 호출로 변수를 대체**한다.

  + **임시 변수를 질의 함수로 바꾸기**
    + 임시 변수들 때문에 로컬 범위에 존재하는 이름이 많아지면 함수 추출이 복잡해지므로, 임시 변수를 질의 함수로 변경한다.
      1. 임시 변수의 대입문을 함수로 추출한다.
      2. (변수 인라인하기) 추출한 함수로 해당 임시 변수를 대체한다.
      3. (함수 선언 바꾸기) 임시 변수를 매개 변수로 사용하던 함수에서, 추출한 함수를 사용하는 방식으로 매개 변수를 제거할 수 있는지 확인한다.
         1. 임시 변수를 매개 변수로 사용하던 함수 내부에서 새로운 추출 함수를 매개변수 대신 사용하도록 수정하고,
         2. 필요 없어진 매개 변수를 함수 선언에서 제거한다.
    + **지역 변수를 제거해서 얻는 가장 큰 장점**은, **유효 범위를 신경 쓸 대상이 줄어 함수 추출 작업이 훨씬 쉬워진다**는 점이다.

  + **함수 변수를 일반 함수로 변경하기**
    + 임시 변수에 함수 포인터처럼 함수를 대입한 형태는, 함수를 직접 선언하여 사용한다.
    + 함수의 이름을 잘 지어야 한다. 긴 함수를 작게 쪼개는 리팩터링은 이름을 잘 지어야만 효과가 있다. 이름이 좋으면 함수 본문을 읽지 않고도 무슨 일을 하는지 알 수 있다.

  + **반복문을 돌며 값을 누적하는 변수**
    1. 변수 값이 누적되는 코드를 별도의 반복문으로 분리한다. (반복문 쪼개기)
    2. 누적하는 변수의 선언문을 분리한 반복문 앞으로 옮긴다. (문장 슬라이드하기)
    3. 변수 선언과 반복문을 모아 하나의 함수로 만든다. (함수 추출하기)
    4. 추출한 함수로 누적하던 변수를 새롭게 선언한다. 
       + 해당 변수가 임시 변수라면, 함수 호출로 변수를 대체한다. (변수 인라인하기)
    + 반복문 중복이 성능에 영향을 미치지 않는지 걱정할 수 있다. 때로는 리팩터링이 성능에 상당한 영향을 주기도 한다. 그러나 잘 다듬어진 코드일 때 성능 개선 작업도 훨씬 수월하므로 개의치 않고 리팩터링한다. 리팩터링 과정에서 성능이 크게 떨어졌다면, 리팩터링 후 성능을 개선한다. 대체로 리팩터링 덕분에 성능 개선도 더 효과적으로 수행할 수 있다.
      
      > 💡 리팩터링으로 인한 성능 문제는 특별한 경우가 아니라면 일단 무시한다. 리팩터링 때문에 성능이 떨어진다면, 리팩터링을 마무리하고 성능을 개선한다.

<br />

## 1.6 계산 단계와 포맷팅 단계 분리하기

+ 하나의 함수 내에 중첩 함수로 들어가 있는 상황에서, 해당 중첩 함수의 기능을 여러 함수가 공통으로 필요한 상황이라면? 

  즉, **여러 함수가** 하나의 함수 내에 정의된 **함수 또는 기능을 공통으로 사용하게 하고 싶다면?**

  각 함수가 똑같이 동작하는 단계와 각기 동작하는 단계로 **함수의 단계를 나눈다. (단계 쪼개기)**

+ 책에서는 statement() 함수를, **데이터를 계산, 처리하고 다음 단계로 전달할 중간 데이터 구조를 생성하는 첫 번째 단계**와, **처리 결과를 표현하는 두 번째 단계**, **두 단계로 분리하는 예제를 진행**한다.

  1. 단계 분리는 이후 공통으로 사용될 기능인, 중첩 함수를 가지고 있는 함수 statement()에서 시작한다. 그 함수를 두 단계로 나누어보자. 먼저 **두 번째 단계가 될 코드를 함수로 뽑아낸다.** 두번째 단계는 결과를 표현하는 출력 코드로, 여기서 추출한 함수는 결과 출력 함수라고 부른다. 지금은 기존 코드 전체가 여기에 해당된다. statement() 함수는 결과 출력 함수를 호출하게 된다. (함수 추출하기)
  2. 다음으로 **두 단계 사이의 중간 데이터 구조를 생성**한다. statement()에서 중간 데이터 구조 역할을 할 객체를 만들고, 결과 출력 함수에 인수로 전달한다. 기존에 결과 출력 함수의 인수로 전달되는 데이터를 중간 데이터 구조로 옮기면, 계산 관련 코드를 statement()로 옮길 수 있다. **결과 출력 함수의 데이터와 데이터 생성에 필요한 함수를, statement()와 중간 데이터로 하나씩 옮기며, 결과 출력 함수에서 필요 없어진 매개변수를 삭제한다.** (함수 옮기기)
  3. statement()로 **데이터를 계산하고 데이터 구조를 생성하는 코드(첫 번째 단계)가 모두 옮겨졌다면, 해당 코드를 모두 별도의 함수로 빼낸다.** 추출한 함수는 중간 데이터 생성을 전담한다. (함수 추출하기)

  + 두 단계가 명확히 분리되었다. 각 코드를 별도 파일에 저장하고, 각 함수의 반환 결과를 담는 변수 이름이 명확한지 확인한다.

<br />

## 1.8 다형성을 활용해 계산 코드 재구성하기

### 조건부 로직은 코드 수정 횟수가 늘어날수록 골칫거리로 전락하기 쉽다.

이를 방지하려면 프로그래밍 언어가 제공하는 구조적인 요소로 적절히 보완해야 한다. 여기서는 객체지향의 핵심인 다형성을 활용하여 재구성해본다. 책의 예제에서는 연극 장르에 따라 공연료와 적립 포인트 계산이 달라지고 있다. 상속 계층을 구성하여 희극 서브 클래스와 비극 서브클래스가 각자 구체적인 계산 로직을 정의하도록 해본다.

<br />

### 조건부 로직을 다형성으로 바꾸기 

: 조건부 코드 덩어리를 다형성을 활용하는 방식으로 바꿔보자.

1. **상속 계층 정의하기**

   1. **상속 계층 클래스 작성**

      **다형성 활용을 위해서는 상속 계층부터 정의**한다. 두 장르가 모두 필요로 하는 공연료와 적립 포인트 계산 함수를 담는 계산기 클래스를 작성한다. 조건부 로직을 이용하여 변수에 값을 대입하는 곳에서 계산기가 필요할 것이다. **계산기에는 공연에 대한 정보가 필요하므로, 생성자의 인자로 공연에 대한 정보를 준다. 공연할 연극 정보도 계산기로 전달한다.**

   2. **함수 옮기기**

      함수를 상속 계층의 클래스로 옮긴다. 함수를 다른 컨텍스트(모듈, 클래스 등)로 옮기는 것은 큰 작업이므로, 작업을 단계별로 차근차근 진행한다.

      1. **계산 코드를** 계산기 **클래스로 옮겨** 메서드를 만들고, 메서드에서는 **클래스의 멤버 변수를 사용하도록 수정**한다.
      2. 기존에 계산 코드를 가지고 있던 **원본 함수에서 클래스의 메서드를 사용하여 작업하도록 수정**하고, 코드가 **제대로 작동하는지 확인**한다. 
      3. 문제없이 작동한다면 계산 코드의 결과를 필요로 하는 변수가, 기존의 원본 함수가 아닌 클래스의 메서드를 직접 호출하도록 함수를 인라인한다.

2. **다형성 지원하기**

   1. **생성자를 팩터리 함수로 바꾸기**

      다형성을 지원하기 위해서는, 서브 클래스를 준비하고 그 중 **적합한 서브 클래스를 사용하도록 만들어야 한다.** 계산기 클래스를 상속하는 비극 공연 계산기와 희극 공연 계산기 서브 클래스를 작성한다. **자바스크립트에서는 생성자가 서브 클래스의 인스턴스를 반환할 수 없으므로, 함수에서 적절한 서브 클래스를 선택하고, 해당 서브 클래스를 생성하여 반환하도록 한다.** 책에서는 돌려줄 서브 클래스가 없는 경우, 에러를 던지도록 처리하였다.

   2. **조건부 로직을 다형성으로 바꾸기**

      슈퍼클래스의 계산 로직을 오버라이드하도록, 각 장르에서 **필요한 계산 코드를 담은 메서드를 서브 클래스에 정의**한다. 이때 **공통되는 일반적인 계산은 슈퍼클래스에 정의하고, 장르마다 달라지는 부분만 필요할 때 오버라이드 하도록 한다.** 책에서는 상위 계층의 계산기 클래스에서 메서드가 호출되는 경우, 에러를 던지도록 처리하였다.

<br />

## 1.10 마치며

+ 1장에서는 리팩터링을 크게 세 단계로 진행했다.

  1. 원본 코드를 중첩 함수 여러 개로 나누고 **(함수 추출하기)**
  2. 계산 코드와 결과 코드를 분리했다. **(단계 쪼개기)**
  3. 마지막으로 조건부 로직인 계산 로직을 다형성으로 표현했다. **(조건부 로직을 다형성으로 바꾸기)**

+ 프로그래머 사이에서 어떤 코드가 좋은 코드인지에 대한 의견은 분분하다. 하지만 **취향을 넘어서는 관점이 분명 존재하며, 코드를 '수정하기 쉬운 정도'야 말로 좋은 코드를 가늠하는 확실한 방법이라고 믿는다.** 코드는 명확해야 한다. 코드를 **수정해야 할 상황이 되면 고쳐야 할 곳을 쉽게 찾을 수 있고 오류 없이 빠르게 수정할 수 있어야 한다.** **건강한 코드 베이스는 생산성을 극대화하고, 고객에게 필요한 기능을 더 빠르고 저렴한 비용으로 제공하도록 해준다.** 코드를 건강하게 관리하려면, 프로그래밍 팀의 현재와 이상의 차이에 항상 신경 쓰며, 이상에 가까워지도록 리팩터링해야 한다.

  > 💡 좋은 코드를 가늠하는 확실한 방법은 '얼마나 수정하기 쉬운가'다.

+ 리팩터링을 효과적으로 하는 핵심은, **단계를 잘게 나눠야 더 빠르게 처리할 수 있고,** 코드는 절대 깨지지 않으며, 이러한 **작은 단계들이 모여서 상당히 큰 변화를 이룰 수 있다는 사실을 깨닫는 것**이다.

