# Chapter 01. 리팩터링: 첫 번째 예시

> 🌱 1장에서는 리팩터링 예시를 보고, 그 과정을 따라가면서 리팩터링을 전반적으로 어떻게 수행하는지 감을 잡아본다. 실습을 진행하며 주요 내용과 문장을 아래에 정리하였다.

<br />

## 1.2 예시 프로그램을 본 소감

+ 코드를 수정하려면 사람이 개입되고, 사람은 코드의 미적 상태에 민감하다. **설계가 나쁜 시스템은 수정하기 어렵다.** 원하는 동작을 수행하도록 하기 위해 수정해야 할 부분을 찾고, 기존 코드와 잘 맞물려 작동하게 할 방법을 강구하기 어렵기 때문이다. 수정할 부분을 찾기 어려우므로 실수와 버그가 생길 가능성도 높아진다.

> 💡 프로그램이 새로운 기능을 추가하기에 편한 구조가 아니라면, 먼저 **기능을 추가하기 쉬운 형태로 리팩터링하고 나서, 원하는 기능을 추가**한다.

<br />

## 1.3 리팩터링의 첫 단계

+ 리팩터링의 첫 단계는 리팩터링 영역을 꼼꼼하게 검사해 줄 테스트 코드를 마련하는 것이다. 리팩터링 기법들이 버그 발생 가능성을 최소화하도록 구성됐다고 하나, 실제 작업은 사람이 하므로 언제든 실수할 수 있다.
+ 성공/실패를 스스로 판단하는 자가 진단 테스트를 만든다. 그렇지 않으면 노트에 적어둔 값을 일일이 비교해야 하고, 속도가 상당히 떨어진다. 자가 진단 테스트를 작성하고 실행하는데 필요한 모든 기능을 제공하는 최신 테스트 프레임워크를 사용하자. 테스트를 작성하는 데 시간이 걸리지만, 디버깅 시간이 줄어 전체 작업 시간은 오히려 단축된다.

> 💡 **리팩터링 하기 전에 제대로 된  테스트부터 마련**한다. **테스트는 반드시 자가 진단**하도록 만든다.

<br />

## 1.4 statement() 함수 쪼개기

+ 워드 커닝햄이 말하길, 코드를 분석해서 얻은 정보를 휘발성이 높기로 악명 높은 저장장치인 내 머릿 속에 기록되므로, 재빨리 코드에 반영해야 한다.

+ **함수 추출하기**
  
  + 가장 먼저 유효범위를 벗어나는 변수, 즉 새 함수에서는 곧바로 사용할 수 없는 변수가 있는지 확인한다. 함수 안에서 해당 변수들의 값이 변경되는지 확인한다. 
    + 값을 변경하지 않는 경우, 매개 변수로 함수에 전달한다.
    + 값이 변하는 경우, 해당 변수 값을 초기화하는 코드를 함수에 포함시키거나, 변수의 값을 반환하는 등의 작업이 필요하다.
    
  + 함수 추출 후에는 코드를 들여다보며 지금보다 명확하게 표현할 수 있는지 검토한다. 변수, 인수의 이름 ... 을 더 명확하게 바꿔보자. 좋은 코드라면 하는 일이 명확히 드러나야하며, 이때 변수 이름은 큰 역할을 한다.
  
    > 💡 컴퓨터가 이해하는 코드는 바보도 작성할 수 있다. **사람이 이해하도록 작성하는 프로그래머가 진정한 실력자**다.
  
+ 수정 후에는 곧바로 컴파일하고, 테스트해서 실수가 없는지 확인한다. **조금씩 변경하고 매번 테스트하는 것은 리팩터링 절차의 핵심이다.** 한 번에 너무 많이 수정하려다 실수를 저지르면 디버깅하기 어려워 결과적으로 작업 시간이 늘어난다.

  > 💡 **리팩터링은 프로그램 수정을 작은 단계로 나눠 진행**한다. 그래서 중간에 실수하더라도 버그를 쉽게 찾을 수 있다.

+ 수정사항을 테스트해보고 문제가 없다면, 다음 단계로 변경사항을 로컬 버전 관리 시스템에 커밋한다. 하나의 리팩터링을 문제없이 끝낼 때 마다 커밋해두면, 중간에 문제가 생기더라도 이전의 정상 상태로 쉽게 돌아갈 수 있다. 자잘한 변경들이 어느 정도 의미있는 단위로 뭉쳐지면 공유 저장소로 푸시한다.

+ **변수 제거하기**
  
  + **변수 인라인하기**
    + **임시 변수가 함수를 호출**하고, 그 변수**값이 다시 바뀌지 않는 경우, 함수 호출로 변수를 대체**한다.

  + **임시 변수를 질의 함수로 바꾸기**
    + 임시 변수들 때문에 로컬 범위에 존재하는 이름이 많아지면 함수 추출이 복잡해지므로, 임시 변수를 질의 함수로 변경한다.
      1. 임시 변수의 대입문을 함수로 추출한다.
      2. (변수 인라인하기) 추출한 함수로 해당 임시 변수를 대체한다.
      3. (함수 선언 바꾸기) 임시 변수를 매개 변수로 사용하던 함수에서, 추출한 함수를 사용하는 방식으로 매개 변수를 제거할 수 있는지 확인한다.
         1. 임시 변수를 매개 변수로 사용하던 함수 내부에서 새로운 추출 함수를 매개변수 대신 사용하도록 수정하고,
         2. 필요 없어진 매개 변수를 함수 선언에서 제거한다.
    + **지역 변수를 제거해서 얻는 가장 큰 장점**은, **유효 범위를 신경 쓸 대상이 줄어 함수 추출 작업이 훨씬 쉬워진다**는 점이다.

  + **함수 변수를 일반 함수로 변경하기**
    + 임시 변수에 함수 포인터처럼 함수를 대입한 형태는, 함수를 직접 선언하여 사용한다.
    + 함수의 이름을 잘 지어야 한다. 긴 함수를 작게 쪼개는 리팩터링은 이름을 잘 지어야만 효과가 있다. 이름이 좋으면 함수 본문을 읽지 않고도 무슨 일을 하는지 알 수 있다.

  + **반복문을 돌며 값을 누적하는 변수**
    1. 변수 값이 누적되는 코드를 별도의 반복문으로 분리한다. (반복문 쪼개기)
    2. 누적하는 변수의 선언문을 분리한 반복문 앞으로 옮긴다. (문장 슬라이드하기)
    3. 변수 선언과 반복문을 모아 하나의 함수로 만든다. (함수 추출하기)
    4. 추출한 함수로 누적하던 변수를 새롭게 선언한다. 
       + 해당 변수가 임시 변수라면, 함수 호출로 변수를 대체한다. (변수 인라인하기)
    + 반복문 중복이 성능에 영향을 미치지 않는지 걱정할 수 있다. 때로는 리팩터링이 성능에 상당한 영향을 주기도 한다. 그러나 잘 다듬어진 코드일 때 성능 개선 작업도 훨씬 수월하므로 개의치 않고 리팩터링한다. 리팩터링 과정에서 성능이 크게 떨어졌다면, 리팩터링 후 성능을 개선한다. 대체로 리팩터링 덕분에 성능 개선도 더 효과적으로 수행할 수 있다.
      
      > 💡 리팩터링으로 인한 성능 문제는 특별한 경우가 아니라면 일단 무시한다. 리팩터링 때문에 성능이 떨어진다면, 리팩터링을 마무리하고 성능을 개선한다.

