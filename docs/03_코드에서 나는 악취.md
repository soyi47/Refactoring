# Chapter 03. 코드에서 나는 악취

> 🌱 3장에서는 리팩터링할 시점을 찾아본다. 리팩터링이 필요한 혹은 아주 절실한 코드에는 일정한 패턴이 있다. 이 장을 읽고 코드가 풍기는 악취가 무엇인지 찾아보자. 그런 다음 해법으로 제시한 리팩터링 기법을 책의 6~12장에서 찾아 읽고 냄새를 없애는데 도움이 될지 생각해본다. 3장은 켄트 벡과 마틴 파울러가 함께 집필했다. 

<br />

## 3.1 기이한 이름 Mysterious Name

+ 코드는 단순하고 명료하게 작성해야 한다. 코드를 명료하게 표현하는 데 가장 중요한 요소 하나는 바로 '이름'이다. 그래서 함수, 모듈, 변수, 클래스 등은 **그 이름만 보고도 각각이 무슨 일을 하고 어떻게 사용해야 하는지 명확히 알 수 있도록 엄청나게 신경 써서 이름을 지어야 한다.**
+ 이름 바꾸기는 단순히 이름을 다르게 표현하는 연습이 아니다. **마땅한 이름이 떠오르지 않는다면 설계에 더 근본적인 문제가 숨어 있을 가능성이 높다.** 그래서 **혼란스러운 이름을 잘 정리하다보면 코드가 훨씬 간결해진 때가 많다.**

<br />

## 3.2 중복 코드 Duplicated Code

+ 코드가 중복되면 각각을 볼때마다 차이점이 없는지 주의 깊게 봐야하고, 하나를 변경할 때는 다른 비슷한 코드들도 모두 살펴보고 적절히 수행해야하는 부담이 생긴다. 똑같은 코드 구조가 여러 곳에서 반복된다면 하나로 통합하여 더 나은 프로그램을 만들 수 있다.

+ 먼저 **문장 슬라이스하기**로 비슷한 부분을 한 곳에 모으고, **함수 추출하기**를 써서 추출된 메서드를 호출하도록 바꾼다. 같은 부모로부터 파생된 서브 클래스들에 코드가 중복되어 있다면, **메서드 올리기**를 적용해 부모로 옮긴다.

<br />

## 3.3 긴 함수 Long Function

+ 간접 호출(indirection)의 효과, 즉 코드를 이해하고, 공유하고, 선택하기 쉬워진다는 장점은 함수를 짧게 구성할 때 나오는 것이다. 물론 코드를 읽는 사람 입장에서는 함수가 하는 일을 파악하기 위해 왔다 갔다 하므로 여전히 부담이 된다. 이때 **짧은 함수로 구성된 코드를 이해하기 쉽게 만드는 가장 확실한 방법은 좋은 이름**이다. 함수 이름을 잘 지어두면 본문 코드를 볼 이유가 사라진다. 이를 위해서는 훨씬 적극적으로 함수를 쪼개야 한다. 주석을 달아야 할 만한 부분은 무조건 함수로 만들고, 함수 이름은 동작 방식이 아닌 '의도(intention)'가 드러나게 짓는다. 심지어 **원래 코드보다 길어지더라도 함수로 뽑는다. 단, 함수 이름에 코드의 목적을 드러내야 한다. 핵심은 함수의 길이가 아닌,  함수의 목적(의도)과 구현 코드의 괴리가 얼마나 큰가다.** 즉, '무엇을 하는지'를 코드가 잘 설명해주지 못할수록 함수로 만드는 게 유리하다.
+ 함수를 짧게 만드는 작업의 99%는 **함수 추출하기**가 차지한다. **함수 본문에서 따로 묶어 빼내면 좋은 코드 덩어리를 찾아 새로운 함수로 만드는 것**이다.
  + **많은 매개변수와 임시 변수는 추출 작업에 방해**가 된다. **임시 변수를 질의 함수로 바꾸기**로 임시 변수의 수를, **매개변수 객체 만들기**와 **객체 통째로 넘기기**로는 매개변수의 수를 줄일 수 있을 것이다. 이를 적용해도 여전히 임시 변수와 매개변수가 너무 많다면, 더 큰 수술이라 할 수 있는 **함수를 명령으로 바꾸기**를 고려해보자.
  + **추출한 코드 덩어리는 어떻게 찾아낼까?**
    1. **주석**을 참고하는 것 - 주석은 코드만으로는 목적을 이해하기 어려운 부분에 달려있는 경우가 많다. **주석을 주석이 설명하는 코드와 함께 함수로 빼내고, 함수 이름은 주석 내용을 토대로 짓는다.** 코드가 단 한 줄이어도 설명할 필요가 있다면 함수로 추출한다.
    2. **조건문이나 반복문**
       + **조건문 분해**하기. 거대한 switch문을 구성하는 **case문마다 함수 추출하기를 적용**해서 각 case의 본문을 함수 호출문 하나로 바꾼다. 같은 조건을 기준으로 나뉘는 switch문이 여러 개라면 **조건문을 다형성으로 바꾸기**를 적용한다.
       + 반복문은 **반복문 째로 내부 코드와 함께 추출하여 독립된 함수로** 만든다. 함수의 적합한 이름이 떠오르지 않는다면 성격이 다른 두 가지 작업이 섞여 있기 때문일 수 있다. 이때는 과감히 **반복문 쪼개기**를 적용하여 작업을 분리한다.

<br />

## 3.4 긴 매개변수 목록 Long Parameter List

+ 과거에는 함수에 필요한 것들을 모두 매개변수로 전달하여, 전역 데이터가 늘어나는 사태를 막도록 하라고 배웠다. 하지만 **매개변수 목록이 길어지면 그 자체로 이해하기 어려울 때가 많다.**
+ 다른 매개변수에서 값을 얻어올 수 있는 매개변수는, **매개변수를 질의 함수로 바꾸기**로 제거한다.
+ 사용 중인 데이터 구조에서 값을 뽑아 각각을 별개의 매개변수로 전달하는 코드라면, **객체 통째로 넘기기**를 적용하여 원본 데이터 구조를 그대로 전달한다. 
+ 항상 함께 전달되는 매개변수들은 **매개변수 객체 만들기**로 하나로 묶는다.
+ 함수 동작 방식을 정하는 플래그 역할의 매개변수는 **플래그 인수 제거하기**로 없앤다.
+ 클래스는 매개변수 목록을 줄이는 효과적인 수단이기도 하다. 특히 여러 개의 함수가 특정 매개변수들의 값을 공통으로 사용할 때는, **여러 함수를 클래수로 묶기**를 이용하여 공통 값들을 클래스의 필드로 정의한다.

<br />

## 3.5 전역 데이터 Global Data

+ 전역 데이터는 우리가 겪을 수 있는 악취 중 가장 지독한 축에 속한다. 전역 데이터는 코드베이스 어디에서든 건드릴 수 있고, 값을 누가 바꿨는지 찾아낼 방법이 없다는 게 문제다. 버그는 끊임없이 발생하는데 그 원인이 되는 코드를 찾아내기가 굉장히 어렵다. 파라켈수스(Paracelsus)가 말하길 '무엇이든 많이 복용하면 독이 될 수 있다'라고 했다. 이 말은 전역 데이터에 고스란히 적용된다. 전역 데이터가 조금이면 감당하겠지만, 많아지면 걷잡을 수 없게 된다.
+ 이를 방지하기 위해 사용하는 대표적인 리팩터링은 **변수 캡슐화하기**다. 데이터를 함수로 감싸는 것만으로도 데이터를 수정하는 부분을 쉽게 찾을 수 있고, 접근을 통제할 수 있게 된다. 더 나아가 접근자 함수들을 클래스나 모듈에 집어넣고 그 안에서만 사용할 수 있도록 접근 범위를 최소로 줄이는 것도 좋다. 전역 데이터가 아주 조금만 있더라도 캡슐화한다.

<br />

## 3.6 가변 데이터 Mutable Data

+ 코드의 다른 곳에서는 다른 값을 기대한다는 사실을 인식하지 못한 채 데이터를 변경 또는 수정해버리면 프로그램이 오작동한다. 이 문제가 아주 드문 조건에서만 발생하는 경우, 원인을 알아내기가 매우 어렵다. 따라서 **함수형 프로그래밍에서는 데이터는 절대 변하지 않고, 데이터를 변경하려면 원래 데이터는 그대로 둔 채, 변경하려는 값에 해당하는 복사본을 만들어서 반환한다는 개념을 기본으로 삼고 있다.** 함수형 언어가 프로그래밍에서 차지하는 비중이 적고, 변수 값을 바꿀 수 있는 언어를 사용하는 프로그래머가 많지만, 불변성이 주는 장점을 포기할 필요는 없다. **무분별한 데이터 수정에 따른 위험을 줄이는 방법을 사용**하자.
+ **변수 캡슐화하기**를 적용하여, 정해놓은 함수를 거쳐야만 값을 수정할 수 있도록 한다. 이렇게 하면 값이 어떻게 수정되는지 감시하거나 코드를 개선하기 쉽다.
+ 하나의 변수에 용도가 다른 값들을 저장하느라 값을 갱신하는 경우, **변수 쪼개기**를 이용하여 용도별로 독립 변수에 저장하도록 한다. 갱신 로직은 다른 코드와 분리하는 것이 좋다. **문장 슬라이드하기**와 **함수 추출하기**를 이용하여 무언가를 갱신하는 코드를 다른 코드와 분리한다.
+ API를 만들 때는, **질의 함수와 변경 함수 분리하기**를 활용하여, 꼭 필요한 경우가 아니라면 부작용이 있는 코드를 호출할 수 없도록 한다.
+ 가능한 한 **세터 제거하기**를 적용한다. 세터(setter)를 호출하는 클라이언트를 찾는 것만으로도 변수의 유효범위를 줄이는 데 도움될 때가 있다.
+ 값을 다른 곳에서 설정할 수 있는 가변 데이터가 풍기는 악취는 특히 고약하다. 이럴 때는 **파생 변수를 질의 함수로 바꾸기**를 코드 전체에 골고루 적용한다.
+ 변수의 유효범위가 넒어질 수록 위험도 덩달아 커진다. **여러 함수를 클래수로 묶기**나 **여러 함수를 변환 함수로 묶기**를 활용하여, 변수를 갱신하는 코드들의 유효범위를 제한한다. 구조체처럼 내부 필드에 데이터를 담고 있는 변수는, 참조를 값으로 바꾸기를 적용하여 내부 필드를 직접 수정하지 말고, 구조체를 통째로 교체하도록 한다.

<br />

## 3.7 뒤엉킨 변경 Divergent Change

+ 코드를 수정할 때는 시스템에서 고쳐야 할 딱 한 군데를 찾아서 그 부분만 수정할 수 있어야 한다. 이렇게 할 수 없다면 뒤엉킨 변경이 나타날 수 있다. **뒤엉킨 변경은 단일 책임 원칙(SRP, Single Responsibility Principle)이 제대로 지켜지지 않을 때, 즉 하나의 모듈이 서로 다른 이유로 인해 여러 가지 방식으로 변경되는 일이 많을 때 발생한다.** **서로 다른 맥락에서 이루어지는 동작은 독립된 모듈로 분리해야 프로그래밍이 편하다.** 그래야 무언가를 수정할 때 해당 맥락 코드만 이해해도 진행할 수 있다. 개발 초기에는 맥락 사이의 경계를 명확히 나누기 어렵고, 소프트웨어 시스템의 기능이 변경되면서 맥락 간의 경계도 끊임없이 움직이기 때문에, 여러 번 동작을 처리하고 나서야 이 악취가 느껴지는 경우도 많다.
+ 순차적으로 실행되는 게 자연스러운 맥락이라면
  + 다음 맥락에 필요한 데이터를 특정 데이터 구조에 담아 전달하는 식으로 단계 쪼개기
  + 전체 처리 과정 곳곳에서 각기 다른 맥락의 함수를 호출하는 빈도가 높은 경우, 각 맥락에 해당하는 적당한 모듈들을 만들고, 함수 옮기기를 적용하여 관련 함수들을 모으기
  + 여러 맥락의 일에 관여하는 함수가 있다면 옮기기 전에,  함수 추출하기
  + 클래스 추출하기

<br />

## 3.8 산탄총 수술 Shotgun Surgery

+ 산탄총 수술은 뒤엉킨 변경과 비슷하면서도 정반대다. **산탄총 수술과 뒤엉킨 변경은 맥락을 잘 구분하지 못하여 생기기 때문에, 맥락을 명확히 구분하면 해결된다는 점에서는 비슷**하다. 하지만 **뒤엉킨 변경은 여러 맥락이 한 코드에 섞여 들어갔을 때 생기기 때문에 맥락별로 분리해주어야** 하고, **산탄총 수술은 하나의 맥락이 여러 코드에 흩뿌려졌을 때 생기기 때문에 맥락별로 모아주어야 한다**는 점에서 다르다.
+ 산탄총 수술은 코드를 변경할 때마다 자잘하게 수정해야 하는 클래스가 많을 때 감지할 수 있다. 수정할 부분이 전반에 퍼져 있다면 차직도 어렵고 지나치기도 쉽다. 
  + 변경 대상들을 **함수 옮기기**와 **필드 옮기기**로 모두 한 모듈에 묶어둔다.
  + 비슷한 데이터를 다루는 함수가 많은 경우, **여러 함수를 클래스로 묶기**를 적용한다.
  + 데이터 구조를 변환 또는 보강하는 함수들에는 **여러 함수를 변환 함수로 묶기**를 적용한다.
  + 위와 같이 묶은 함수들의 출력 결과를 묶어서 다음 단계의 로직으로 전달할 수 있다면, **단계 쪼개기**를 적용한다.
  + 어설프게 분리된 로직은 **함수 인라인하기**나 **클래스 인라인하기**와 같은 인라인 리팩터링으로 하나로 합치는 것도 좋은 방법이다.

<br />


## 3.9 기능 편애 Feature Envy

+ **기능 편애**는, 어떤 함수가 **자신이 속한 모듈의 함수나 데이터보다 다른 모듈의 함수나 데이터와 상호 작용 할일이 더 많을 때** 감지된다.
  + 프로그램을 **모듈화**할 때는,  ① 코드를 **여러 영역으로 나눈 뒤** ② 영역 **안에서 이뤄지는 상호작용은 최대**한 늘리고, ③ **영역 간에 이뤄지는 상호작용은 최소**로 줄이는데 주력한다.
+ 외부 객체의 게터 메서드 대여섯 개를 호출하도록 작성된 경우, 이 함수가 데이터와 가까이 있고 싶어함이 뚜렷이 드러나므로, **함수 옮기기**를 적용하여 데이터 근처로 옮겨준다.
+ 함수의 일부에서만 기능을 편애하는 경우, 그 부분만 **함수 추출하기**를 적용하여 독립 함수로 빼낸 다음, **함수 옮기기**를 적용하여, 원하는 모듈로 보내준다.
+ 함수가 사용하는 모듈이 다양한 상황에서는 **함수를 어디로 옮길지 명확하게 드러나지 않기도 한다.** 이런 때는 
  + **가장 많은 데이터를 포함한 모듈**로 옮기거나, 
  + **함수 추출하기**로 함수를 여러 조각으로 나눈 후, **각각을 적합한 모듈로 옮긴다.**

+ 디자인 패턴 중 전략 패턴(Strategy Pattern)과 방문자 패턴(Visitor Pattern), 켄트 벡의 자기 위임(Self-Delegation)은 위에서 설명한 규칙을 거스르는 패턴이다. 모두 '뒤엉킨 변경'을 없앨 때 활용하는 패턴들로, '함께 변경할 대상을 한데 모으는 것'을 기본 원칙으로 한다. 데이터와 이를 활용하는 동작은 함께 변경할 때가 많지만, 예외의 경우, 같은 데이터를 다루는 코드를 한 곳에서 변경할 수 있도록 옮긴다.

<br />

## 3.10 데이터 뭉치 Data Clumps

+ 데이터 항목 서너 개가 (클래스의 필드 혹은 여러 메서드의 시그니처 등) 여러 곳에서 항상 뭉쳐 다니는 모습을 흔히 목격할 수 있다. 이렇게 **몰려다니는 데이터 뭉치는 보금자리를 따로 마련해줘야** 마땅하다.
  + 가장 먼저 필드 형태의 데이터 뭉치를 찾아 **클래스 추출하기**를 적용하여 하나의 객체로 묶는다.
    + 간단한 레코드 구조가 아닌, 클래스를 이용하면 좋은 향기를 뿌릴 기회가 생긴다. 새로운 클래스를 만들었다면, 그 클래스로 옮기면 좋을 동작은 없는지 살펴본다.
  + 메서드 시그니처에 있는 데이터 뭉치는, 먼저 **매개변수 객체 만들기** 또는 **객체 통째로 넘기기**를 적용하여 매개변수 수를 줄여본다. 즉시 메서드 호출 코드가 간결해진다. 데이터 뭉치가 앞에서 새로 만든 객체의 필드 중 일부만 사용하더라도, 뽑아낸 필드가 두 개 이상이기만 하면 확실히 예전보다 나아진다.
  + 데이터 뭉치인지 판별하는 방법 : 값 하나를 삭제했을 때 나머지 데이터만으로는 의미가 없다면, 객체로 정리되어야 할 데이터 뭉치다.

<br />

## 3.11 기본형 집착 Primitive Obsession

+ 대부분의 프로그래밍 언어는 정수, 부동소수점 수, 문자열 같은 기본형(primitive type)을 제공한다. 한편 프로그래머 중에는 주어진 문제에 딱 맞는 기초 타입(화폐, 좌표, 구간 등)을 직접 정의하기를 몹시 꺼리는 사람이 많다. (금액을 그냥 숫자형으로 계산하거나, 물리량 계산 시 단위를 무시하는 등...) 이는 특히 문자열을 다루는 코드에서 흔하다. 전화번호는 단순히 문자 집합으로 표현하기 보다, 최소한 사용자에게 보여줄 때 일관된 형식으로 출력해주는 기능을 갖추어야 한다. **자료형을 문자열로만 표현하는 악취는 아주 흔해서, 소위 '문자열화된(stringly typed)' 변수라는 이름도 붙었다.**
+ **기본형을 객체로 바꾸기**를 적용하여 기본형만이 존재하는 코드에서 자료형들이 존재하는 코드로 바꾼다.
+ 기본형으로 표현된 코드가 조건부 동작을 제어하는 타입 코드(type code)로 쓰인 경우, **타입 코드를 서브클래스로 바꾸기**와 **조건부 로직을 다형성으로 바꾸기**를 차례로 적용한다.
+ 자주 함께 몰려다니는 기본형 그룹에는 **클래스 추출하기**와 **매개변수 객체 만들기**를 적용한다.

<br />

