# Chapter 03. 코드에서 나는 악취

> 🌱 3장에서는 리팩터링할 시점을 찾아본다. 리팩터링이 필요한 혹은 아주 절실한 코드에는 일정한 패턴이 있다. 이 장을 읽고 코드가 풍기는 악취가 무엇인지 찾아보자. 그런 다음 해법으로 제시한 리팩터링 기법을 책의 6~12장에서 찾아 읽고 냄새를 없애는데 도움이 될지 생각해본다. 3장은 켄트 벡과 마틴 파울러가 함께 집필했다. 

<br />

## 3.1 기이한 이름 Mysterious Name

+ 코드는 단순하고 명료하게 작성해야 한다. 코드를 명료하게 표현하는 데 가장 중요한 요소 하나는 바로 '이름'이다. 그래서 함수, 모듈, 변수, 클래스 등은 **그 이름만 보고도 각각이 무슨 일을 하고 어떻게 사용해야 하는지 명확히 알 수 있도록 엄청나게 신경 써서 이름을 지어야 한다.**
+ 이름 바꾸기는 단순히 이름을 다르게 표현하는 연습이 아니다. **마땅한 이름이 떠오르지 않는다면 설계에 더 근본적인 문제가 숨어 있을 가능성이 높다.** 그래서 **혼란스러운 이름을 잘 정리하다보면 코드가 훨씬 간결해진 때가 많다.**

<br />

## 3.2 중복 코드 Duplicated Code

+ 코드가 중복되면 각각을 볼때마다 차이점이 없는지 주의 깊게 봐야하고, 하나를 변경할 때는 다른 비슷한 코드들도 모두 살펴보고 적절히 수행해야하는 부담이 생긴다. 똑같은 코드 구조가 여러 곳에서 반복된다면 하나로 통합하여 더 나은 프로그램을 만들 수 있다.

+ 먼저 **문장 슬라이스하기**로 비슷한 부분을 한 곳에 모으고, **함수 추출하기**를 써서 추출된 메서드를 호출하도록 바꾼다. 같은 부모로부터 파생된 서브 클래스들에 코드가 중복되어 있다면, **메서드 올리기**를 적용해 부모로 옮긴다.

<br />

## 3.3 긴 함수 Long Function

+ 간접 호출(indirection)의 효과, 즉 코드를 이해하고, 공유하고, 선택하기 쉬워진다는 장점은 함수를 짧게 구성할 때 나오는 것이다. 물론 코드를 읽는 사람 입장에서는 함수가 하는 일을 파악하기 위해 왔다 갔다 하므로 여전히 부담이 된다. 이때 **짧은 함수로 구성된 코드를 이해하기 쉽게 만드는 가장 확실한 방법은 좋은 이름**이다. 함수 이름을 잘 지어두면 본문 코드를 볼 이유가 사라진다. 이를 위해서는 훨씬 적극적으로 함수를 쪼개야 한다. 주석을 달아야 할 만한 부분은 무조건 함수로 만들고, 함수 이름은 동작 방식이 아닌 '의도(intention)'가 드러나게 짓는다. 심지어 **원래 코드보다 길어지더라도 함수로 뽑는다. 단, 함수 이름에 코드의 목적을 드러내야 한다. 핵심은 함수의 길이가 아닌,  함수의 목적(의도)과 구현 코드의 괴리가 얼마나 큰가다.** 즉, '무엇을 하는지'를 코드가 잘 설명해주지 못할수록 함수로 만드는 게 유리하다.
+ 함수를 짧게 만드는 작업의 99%는 **함수 추출하기**가 차지한다. **함수 본문에서 따로 묶어 빼내면 좋은 코드 덩어리를 찾아 새로운 함수로 만드는 것**이다.
  + **많은 매개변수와 임시 변수는 추출 작업에 방해**가 된다. **임시 변수를 질의 함수로 바꾸기**로 임시 변수의 수를, **매개변수 객체 만들기**와 **객체 통째로 넘기기**로는 매개변수의 수를 줄일 수 있을 것이다. 이를 적용해도 여전히 임시 변수와 매개변수가 너무 많다면, 더 큰 수술이라 할 수 있는 **함수를 명령으로 바꾸기**를 고려해보자.
  + **추출한 코드 덩어리는 어떻게 찾아낼까?**
    1. **주석**을 참고하는 것 - 주석은 코드만으로는 목적을 이해하기 어려운 부분에 달려있는 경우가 많다. **주석을 주석이 설명하는 코드와 함께 함수로 빼내고, 함수 이름은 주석 내용을 토대로 짓는다.** 코드가 단 한 줄이어도 설명할 필요가 있다면 함수로 추출한다.
    2. **조건문이나 반복문**
       + **조건문 분해**하기. 거대한 switch문을 구성하는 **case문마다 함수 추출하기를 적용**해서 각 case의 본문을 함수 호출문 하나로 바꾼다. 같은 조건을 기준으로 나뉘는 switch문이 여러 개라면 **조건문을 다형성으로 바꾸기**를 적용한다.
       + 반복문은 **반복문 째로 내부 코드와 함께 추출하여 독립된 함수로** 만든다. 함수의 적합한 이름이 떠오르지 않는다면 성격이 다른 두 가지 작업이 섞여 있기 때문일 수 있다. 이때는 과감히 **반복문 쪼개기**를 적용하여 작업을 분리한다.

<br />

## 3.4 긴 매개변수 목록 Long Parameter List

+ 과거에는 함수에 필요한 것들을 모두 매개변수로 전달하여, 전역 데이터가 늘어나는 사태를 막도록 하라고 배웠다. 하지만 **매개변수 목록이 길어지면 그 자체로 이해하기 어려울 때가 많다.**
+ 다른 매개변수에서 값을 얻어올 수 있는 매개변수는, **매개변수를 질의 함수로 바꾸기**로 제거한다.
+ 사용 중인 데이터 구조에서 값을 뽑아 각각을 별개의 매개변수로 전달하는 코드라면, **객체 통째로 넘기기**를 적용하여 원본 데이터 구조를 그대로 전달한다. 
+ 항상 함께 전달되는 매개변수들은 **매개변수 객체 만들기**로 하나로 묶는다.
+ 함수 동작 방식을 정하는 플래그 역할의 매개변수는 **플래그 인수 제거하기**로 없앤다.
+ 클래스는 매개변수 목록을 줄이는 효과적인 수단이기도 하다. 특히 여러 개의 함수가 특정 매개변수들의 값을 공통으로 사용할 때는, **여러 함수를 클래수로 묶기**를 이용하여 공통 값들을 클래스의 필드로 정의한다.

<br />

## 3.5 전역 데이터 Global Data

+ 전역 데이터는 우리가 겪을 수 있는 악취 중 가장 지독한 축에 속한다. 전역 데이터는 코드베이스 어디에서든 건드릴 수 있고, 값을 누가 바꿨는지 찾아낼 방법이 없다는 게 문제다. 버그는 끊임없이 발생하는데 그 원인이 되는 코드를 찾아내기가 굉장히 어렵다. 파라켈수스(Paracelsus)가 말하길 '무엇이든 많이 복용하면 독이 될 수 있다'라고 했다. 이 말은 전역 데이터에 고스란히 적용된다. 전역 데이터가 조금이면 감당하겠지만, 많아지면 걷잡을 수 없게 된다.
+ 이를 방지하기 위해 사용하는 대표적인 리팩터링은 **변수 캡슐화하기**다. 데이터를 함수로 감싸는 것만으로도 데이터를 수정하는 부분을 쉽게 찾을 수 있고, 접근을 통제할 수 있게 된다. 더 나아가 접근자 함수들을 클래스나 모듈에 집어넣고 그 안에서만 사용할 수 있도록 접근 범위를 최소로 줄이는 것도 좋다. 전역 데이터가 아주 조금만 있더라도 캡슐화한다.

<br />

## 3.6 가변 데이터 Mutable Data

+ 코드의 다른 곳에서는 다른 값을 기대한다는 사실을 인식하지 못한 채 데이터를 변경 또는 수정해버리면 프로그램이 오작동한다. 이 문제가 아주 드문 조건에서만 발생하는 경우, 원인을 알아내기가 매우 어렵다. 따라서 **함수형 프로그래밍에서는 데이터는 절대 변하지 않고, 데이터를 변경하려면 원래 데이터는 그대로 둔 채, 변경하려는 값에 해당하는 복사본을 만들어서 반환한다는 개념을 기본으로 삼고 있다.** 함수형 언어가 프로그래밍에서 차지하는 비중이 적고, 변수 값을 바꿀 수 있는 언어를 사용하는 프로그래머가 많지만, 불변성이 주는 장점을 포기할 필요는 없다. **무분별한 데이터 수정에 따른 위험을 줄이는 방법을 사용**하자.
+ **변수 캡슐화하기**를 적용하여, 정해놓은 함수를 거쳐야만 값을 수정할 수 있도록 한다. 이렇게 하면 값이 어떻게 수정되는지 감시하거나 코드를 개선하기 쉽다.
+ 하나의 변수에 용도가 다른 값들을 저장하느라 값을 갱신하는 경우, **변수 쪼개기**를 이용하여 용도별로 독립 변수에 저장하도록 한다. 갱신 로직은 다른 코드와 분리하는 것이 좋다. **문장 슬라이드하기**와 **함수 추출하기**를 이용하여 무언가를 갱신하는 코드를 다른 코드와 분리한다.
+ API를 만들 때는, **질의 함수와 변경 함수 분리하기**를 활용하여, 꼭 필요한 경우가 아니라면 부작용이 있는 코드를 호출할 수 없도록 한다.
+ 가능한 한 **세터 제거하기**를 적용한다. 세터(setter)를 호출하는 클라이언트를 찾는 것만으로도 변수의 유효범위를 줄이는 데 도움될 때가 있다.
+ 값을 다른 곳에서 설정할 수 있는 가변 데이터가 풍기는 악취는 특히 고약하다. 이럴 때는 **파생 변수를 질의 함수로 바꾸기**를 코드 전체에 골고루 적용한다.
+ 변수의 유효범위가 넒어질 수록 위험도 덩달아 커진다. **여러 함수를 클래수로 묶기**나 **여러 함수를 변환 함수로 묶기**를 활용하여, 변수를 갱신하는 코드들의 유효범위를 제한한다. 구조체처럼 내부 필드에 데이터를 담고 있는 변수는, 참조를 값으로 바꾸기를 적용하여 내부 필드를 직접 수정하지 말고, 구조체를 통째로 교체하도록 한다.

<br />

## 3.7 뒤엉킨 변경 Divergent Change

+ 코드를 수정할 때는 시스템에서 고쳐야 할 딱 한 군데를 찾아서 그 부분만 수정할 수 있어야 한다. 이렇게 할 수 없다면 뒤엉킨 변경이 나타날 수 있다. **뒤엉킨 변경은 단일 책임 원칙(SRP, Single Responsibility Principle)이 제대로 지켜지지 않을 때, 즉 하나의 모듈이 서로 다른 이유로 인해 여러 가지 방식으로 변경되는 일이 많을 때 발생한다.** **서로 다른 맥락에서 이루어지는 동작은 독립된 모듈로 분리해야 프로그래밍이 편하다.** 그래야 무언가를 수정할 때 해당 맥락 코드만 이해해도 진행할 수 있다. 개발 초기에는 맥락 사이의 경계를 명확히 나누기 어렵고, 소프트웨어 시스템의 기능이 변경되면서 맥락 간의 경계도 끊임없이 움직이기 때문에, 여러 번 동작을 처리하고 나서야 이 악취가 느껴지는 경우도 많다.
+ 순차적으로 실행되는 게 자연스러운 맥락이라면
  + 다음 맥락에 필요한 데이터를 특정 데이터 구조에 담아 전달하는 식으로 단계 쪼개기
  + 전체 처리 과정 곳곳에서 각기 다른 맥락의 함수를 호출하는 빈도가 높은 경우, 각 맥락에 해당하는 적당한 모듈들을 만들고, 함수 옮기기를 적용하여 관련 함수들을 모으기
  + 여러 맥락의 일에 관여하는 함수가 있다면 옮기기 전에,  함수 추출하기
  + 클래스 추출하기

<br />

## 3.8 산탄총 수술 Shotgun Surgery

+ 산탄총 수술은 뒤엉킨 변경과 비슷하면서도 정반대다. **산탄총 수술과 뒤엉킨 변경은 맥락을 잘 구분하지 못하여 생기기 때문에, 맥락을 명확히 구분하면 해결된다는 점에서는 비슷**하다. 하지만 **뒤엉킨 변경은 여러 맥락이 한 코드에 섞여 들어갔을 때 생기기 때문에 맥락별로 분리해주어야** 하고, **산탄총 수술은 하나의 맥락이 여러 코드에 흩뿌려졌을 때 생기기 때문에 맥락별로 모아주어야 한다**는 점에서 다르다.
+ 산탄총 수술은 코드를 변경할 때마다 자잘하게 수정해야 하는 클래스가 많을 때 감지할 수 있다. 수정할 부분이 전반에 퍼져 있다면 차직도 어렵고 지나치기도 쉽다. 
  + 변경 대상들을 **함수 옮기기**와 **필드 옮기기**로 모두 한 모듈에 묶어둔다.
  + 비슷한 데이터를 다루는 함수가 많은 경우, **여러 함수를 클래스로 묶기**를 적용한다.
  + 데이터 구조를 변환 또는 보강하는 함수들에는 **여러 함수를 변환 함수로 묶기**를 적용한다.
  + 위와 같이 묶은 함수들의 출력 결과를 묶어서 다음 단계의 로직으로 전달할 수 있다면, **단계 쪼개기**를 적용한다.
  + 어설프게 분리된 로직은 **함수 인라인하기**나 **클래스 인라인하기**와 같은 인라인 리팩터링으로 하나로 합치는 것도 좋은 방법이다.

<br />


## 3.9 기능 편애 Feature Envy

+ **기능 편애**는, 어떤 함수가 **자신이 속한 모듈의 함수나 데이터보다 다른 모듈의 함수나 데이터와 상호 작용 할일이 더 많을 때** 감지된다.
  + 프로그램을 **모듈화**할 때는,  ① 코드를 **여러 영역으로 나눈 뒤** ② 영역 **안에서 이뤄지는 상호작용은 최대**한 늘리고, ③ **영역 간에 이뤄지는 상호작용은 최소**로 줄이는데 주력한다.
+ 외부 객체의 게터 메서드 대여섯 개를 호출하도록 작성된 경우, 이 함수가 데이터와 가까이 있고 싶어함이 뚜렷이 드러나므로, **함수 옮기기**를 적용하여 데이터 근처로 옮겨준다.
+ 함수의 일부에서만 기능을 편애하는 경우, 그 부분만 **함수 추출하기**를 적용하여 독립 함수로 빼낸 다음, **함수 옮기기**를 적용하여, 원하는 모듈로 보내준다.
+ 함수가 사용하는 모듈이 다양한 상황에서는 **함수를 어디로 옮길지 명확하게 드러나지 않기도 한다.** 이런 때는 
  + **가장 많은 데이터를 포함한 모듈**로 옮기거나, 
  + **함수 추출하기**로 함수를 여러 조각으로 나눈 후, **각각을 적합한 모듈로 옮긴다.**

+ 디자인 패턴 중 전략 패턴(Strategy Pattern)과 방문자 패턴(Visitor Pattern), 켄트 벡의 자기 위임(Self-Delegation)은 위에서 설명한 규칙을 거스르는 패턴이다. 모두 '뒤엉킨 변경'을 없앨 때 활용하는 패턴들로, '함께 변경할 대상을 한데 모으는 것'을 기본 원칙으로 한다. 데이터와 이를 활용하는 동작은 함께 변경할 때가 많지만, 예외의 경우, 같은 데이터를 다루는 코드를 한 곳에서 변경할 수 있도록 옮긴다.

<br />

## 3.10 데이터 뭉치 Data Clumps

+ 데이터 항목 서너 개가 (클래스의 필드 혹은 여러 메서드의 시그니처 등) 여러 곳에서 항상 뭉쳐 다니는 모습을 흔히 목격할 수 있다. 이렇게 **몰려다니는 데이터 뭉치는 보금자리를 따로 마련해줘야** 마땅하다.
  + 가장 먼저 필드 형태의 데이터 뭉치를 찾아 **클래스 추출하기**를 적용하여 하나의 객체로 묶는다.
    + 간단한 레코드 구조가 아닌, 클래스를 이용하면 좋은 향기를 뿌릴 기회가 생긴다. 새로운 클래스를 만들었다면, 그 클래스로 옮기면 좋을 동작은 없는지 살펴본다.
  + 메서드 시그니처에 있는 데이터 뭉치는, 먼저 **매개변수 객체 만들기** 또는 **객체 통째로 넘기기**를 적용하여 매개변수 수를 줄여본다. 즉시 메서드 호출 코드가 간결해진다. 데이터 뭉치가 앞에서 새로 만든 객체의 필드 중 일부만 사용하더라도, 뽑아낸 필드가 두 개 이상이기만 하면 확실히 예전보다 나아진다.
  + 데이터 뭉치인지 판별하는 방법 : 값 하나를 삭제했을 때 나머지 데이터만으로는 의미가 없다면, 객체로 정리되어야 할 데이터 뭉치다.

<br />

## 3.11 기본형 집착 Primitive Obsession

+ 기본형 집착 === 기본 타입에 대한 강박 관념. 대부분의 프로그래밍 언어는 정수, 부동소수점 수, 문자열 같은 기본형(primitive type)을 제공한다. 한편 프로그래머 중에는 주어진 문제에 딱 맞는 기초 타입(화폐, 좌표, 구간 등)을 직접 정의하기를 몹시 꺼리는 사람이 많다. (금액을 그냥 숫자형으로 계산하거나, 물리량 계산 시 단위를 무시하는 등...) 이는 특히 문자열을 다루는 코드에서 흔하다. 전화번호는 단순히 문자 집합으로 표현하기 보다, 최소한 사용자에게 보여줄 때 일관된 형식으로 출력해주는 기능을 갖추어야 한다. **자료형을 문자열로만 표현하는 악취는 아주 흔해서, 소위 '문자열화된(stringly typed)' 변수라는 이름도 붙었다.**
+ **기본형을 객체로 바꾸기**를 적용하여 기본형만이 존재하는 코드에서 자료형들이 존재하는 코드로 바꾼다.
+ 기본형으로 표현된 코드가 조건부 동작을 제어하는 타입 코드(type code)로 쓰인 경우, **타입 코드를 서브클래스로 바꾸기**와 **조건부 로직을 다형성으로 바꾸기**를 차례로 적용한다.
+ 자주 함께 몰려다니는 기본형 그룹에는 **클래스 추출하기**와 **매개변수 객체 만들기**를 적용한다.

<br />

## 3.12 반복되는 switch문 Repeated Swtiches

+ 코드에 등장하는 switch 문은 모두 조건부 로직을 다형성 바꾸기로 없애야 할 대상이라고 주장하거나, 모든 조건부 로직 그러니까 심지어 if문까지도 모두 다형성으로 바꿔 없애버려야 한다고 주장하는 이도 있다. 과거와 비교해 지금은 다형성이 널리 자리 잡아서, 단순히 switch 문을 썼다고 해서 자동으로 검토 대상이 되지는 않는다. 분기 조건에 몇 가지 기본형만 쓸 수 있던 예전과 달리, 문자열 등의 복잡한 타입까지 지원하도록 발전된 swtich 문을 제공하는 언어도 많아졌다. 이제는 똑같은 조건부 로직이 반복해 등장하는 코드에 집중해본다. 
+ **중복된 switch문이 문제가 되는 이유**는 **조건절을 하나 추가할 때마다 다른 switch문들도 모두 찾아서 함께 수정해야 하기 때문**이다. 이럴 때 **다형성**은 세련된 무기가 된다.

<br />

## 3.13 반복문 Loops

+ 과거에 우리는 반복문을 탐탁지 않게 여겼지만, 주요 언어들은 더 나은 대안을 제시하지 못했다. 지금은 **일급 함수(first-class function)**를 지원하는 언어가 많아졌기 때문에, **반복문을 파이프라인으로 바꾸기**를 적용해서 **시대에 걸맞지 않은 반복문을 제거**할 수 있게 됐다. 필터(filter)나 맵(map) 같은 **파이프라인 연산을 사용하면 코드에서 각 원소들이 어떻게 처리되는지 쉽게 파악**할 수 있다.
  + **일급함수** ? 함수를 다른 변수와 동일하게 다루는 언어는 **일급 함수**를 가졌다고 표현합니다. 예를 들어, 일급 함수를 가진 언어에서는 함수를 다른 함수에 매개변수로 제공하거나, 함수가 함수를 반환할 수 있으며, 변수에도 할당할 수 있습니다. (from MDN)

<br />

## 3.14 성의 없는 요소 Lazy Element

+ 우리는 코드의 구조를 잡을 때 프로그램 요소(프로그래밍 언어가 제공하는 함수(메서드), 클래스, 인터페이스 등 코드 구조를 잡는 데 활용되는 요소)를 사용하는 것을 좋아한다. 하지만 그 구조가, 본문 코드를 그대로 쓰는 것과 다름 없거나, 실질적인 메서드가 하나 뿐인 클래스인 상황도 있다. 이는 나중에 본문이나 메서드를 추가할 생각이었지만 어떤 이유로 그렇게 하지 못했거나, 클래스가 리팩터링을 거치면서 역할이 줄어든 상황일 수 있다. 어쨌든 이는 **프로그램 요소로 만든 구조가 필요 없는 상황**이다. **이런 요소는 제거하는 것이 좋다.** 이 제거 작업은 **함수 인라인하기**나 클래스 인라인하기로 처리한다. 상속을 사용했다면 **계층 합치기**를 적용한다.

<br />

## 3.15 추측성 일반화 Speculative Generality

+ **나중에 필요할 거라는 생각으로**, 당장 필요 없는 모든 종류의 후킹(hooking) 포인트와 특이 케이스 처리 로직을 **작성해두어, 이후 이해하거나 관리하기 어려워진 코드.** 미래를 대비하여 작성한 코드를 실제로 사용하게 되면 다행이지만, **사용하지 않으면 쓸데 없는 낭비**이므로 당장 걸리적 거리는 코드는 제거한다.
+ 하는 일이 거의 없는 추상 클래스는 **계층 합치기**로 제거
+ 쓸데없이 위임하는 코드는 **함수 인라인하기**나 **클래스 인라인하기**로 제거
+ 본문에서 사용되지 않는 매개변수 혹은 나중에 필요할 거라는 생각에 추가해두었지만 사용한 적 없는 매개변수는 **함수 선언 바꾸기**로 제거
+ 테스트 코드 외에 사용되지 않는 함수나 클래스에서 흔히 발견된다. 발견 시 테스트 케이스부터 삭제하고 **죽은 코드 제거하기**로 제거한다.

<br />

## 3.16 임시 필드 Temporary Field

+ 객체를 가져올 때는 당연히 모든 필드가 채워져 있으리라 기대하는 게 보통이라, **특정 상황에서만 값이 설정되는 임시 필드를 작성하면 코드를 이해하기 어렵다.** 
+ 이런 임시 필드를 발견하면 **클래스 추출하기**로 클래스로 옮겨주고, 그 다음 **함수 옮기기**로 임시 임시 필드와 관련된 코드를 모두 새 클래스에 넣는다. 
+ 임시 필드가 유효한지 확인하고 동작하는 조건부 로직들은, **특이 케이스 추가하기**로 필드가 유요하지 않은 때를 위한 대안 클래스를 만들어 제거한다.

<br />

## 3.17 메시지 체인 Messsage Chains

+ **메시지 체인** ? **객체에 다른 객체를 요청하는 작업이 연쇄적으로 이어지는** 코드. 클라이언트가 한 객체를 통해 다른 객체를 얻은 뒤, 방금 얻은 객체에 또 다른 객체를 요청하는 식.
  + 예를 들어 게터가 꼬리를 물고 이어지거나 임시 변수들이 줄줄이 나열되는 식의 코드는, 클라이언트가 객체 내비게이션 구조에 종속됐음을 의미하고, 이때 내비게이션 중간 단계를  수정하면 클라이언트 코드도 수정해야 한다.
  + 메시지 체인의 예시
    ```javascript
    managerName = aPerson.department.manager.name;
    ```
  
+ **위임 숨기기** 리팩터링은 메시지 체인의 다양한 연결점에 적용할 수 있다. 이때 **최종 결과 객체가 어떻게 쓰이는지부터 살펴보는 게 좋다.** (원칙적으로는 모든 객체에 적용할 수 있으나 그러다 보면 중간 객체들이 모두 중개자가 되어버림) 
  **함수 추출하기**로 결과 객체를 사용하는 코드 일부를 따로 빼낸 다음, **함수 옮기기**로 체인을 숨길 수 있는지 확인한다. 체인을 구성하는 특정 객체 하나를 사용하는 클라이언트들에서, 특정 객체 그 이후의 객체들도 사용하길 요구하는 클라이언트들이 많다면, 해당 요구를 처리해줄 메서드를 추가한다.
  
  + 위임 숨기기 적용 예시
    '체인을 구성하는 모든 객체에 위임 숨기기를 적용할 수 있다.' => 부서장 이름을 반환하는 메서드를 사람 클래스에 추가할 수도, 부서 클래스에 추가할 수 있고, 혹은 부서장을 바로 얻는 메서드를 사람 클래스에 추가할 수도 있다.
    ``` javascript
    managerName = aPerson.department.managerName // 관리자 객체(manager)의 존재 숨김. 부서 클래스에서 부서장 이름 반환하는 메서드 사용
    managerName = aPerson.manager.name // 부서 객체(department)의 존재 숨김. 사람 클래스의 부서장 manager 객체를 바로 얻는 메서드 사용
    managerName = aPerson.managerName // 부서 객체와 관리자의 존재를 모두 숨김
    ```

<br />

## 3.18 중개자 Middle Man

+ 객체의 대표적인 기능 중 하나로, 외부로부터 세부사항을 숨겨주는 **캡슐화(encapsulation)**가 있고, 그 과정에서는 **위임(delegation)**이 자주 활용된다. 
+ 하지만 **지나치면 문제가 된다.** 클레스가 제공하는 메서드 중 절반이 다른 클래스에 구현을 위임하고 있다면, **중개자 제거하기**를 활용하여 실제로 일을하는 객체와 직접 소통하도록 한다. 위임 메서드를 제거한 후 남는 일이 거의 없다면, **함수 인라인하기**를 적용하여 호출하는 쪽으로 인라인한다.

<br />
