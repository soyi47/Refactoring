# Chapter 02. 리팩터링 원칙

> 🌱 2장에서는 리팩터링 전반에 적용되는 원칙 몇 가지를 이야기한다.

<br />

## 2.1 리팩터링 정의

+ **리팩터링 refactoring**

  + [명사] 소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 **내부 구조를 변경하는 기법**
  + (-하다) [동사] 소프트웨어의 겉보기 동작은 그대로 유지한 채, **여러 가지 리팩터링 기법을 적용해서 소프트웨어를 재구성하다.**

+ 위에서 제시한 정의를 따르면, **특정한 방식에 따라 코드를 정리하는 것만이 리팩터링**이다. 리팩터링은 **동작을 보존하는 작은 단계를 거쳐 코드를 수정하고, 이 단계들을 순차적으로 연결하여 코드 상에 큰 변화를 만들어내는 일**이다. 개별 리팩터링은 아주 작을 수도 있고, 여러 개가 합쳐진 모습일 수도 있다. 리팩터링하는 동안에는 코드가 항상 정상 작동하므로 전체 작업이 끝나지 않아도 언제든 중단할 수 있다.

  > 💡 누군가 "리팩터링하다가 코드가 깨져서 며칠이나 고생했다"라고 한다면, 십중팔구 리팩터링한 것이 아니다.

+ **코드를 정리하거나 구조를 바꾸는 모든 작업**을 포괄적으로 "**재구성 restructuring**"이라는 용어로 표현한다. 리팩터링은 재구성 중 특수한 하나의 형태로 본다. 작업 단계를 체계적으로 잘게 나누는 방법을 통해, 무엇보다 디버깅하는 데 시간을 뺏기지 않아 작업을 더 빨리 처리할 수 있게 된다.

+ "**겉보기 동작 observable behavior**"을 유지한다는 것은, 리팩터링 하기 전과 후의 **코드가 사용자 관점에서 달라지는 점 없이 똑같이 동작해야 한다**는 의미다.

+ 리팩터링과 성능 최적화

  + 리팩터링과 성능 최적화는 둘 다 코드를 변경하지만 **전반적인 기능을 그대로 유지한다는 점에서 유사**하다. 둘은 **목적에서 차이**를 보인다.
  + 리팩터링의 목적 : 이해하고 수정하기 쉬운 코드로 만드는 것. 성능은 좋아질 수도, 나빠질 수도 있다.
  + 성능 최적화의 목적 : 속도 개선. 목표 성능에 도달하는 과정에서 코드는 더 복잡하고 어려워질 수 있다.

<br />

## 2.2 두 개의 모자

+ **'기능 추가'** 모자 : 기존 코드는 절대 건드리지 않고 **새 기능을 추가하기만 한다.**
+ **'리팩터링'** 모자 : 기능 추가는 절대 하지 않고, **오로지 코드 재구성에 전념**한다. 테스트도 새로 만들지 않는다. 부득이 인터페이스를 변경하거나, 놓친 테스트 케이스를 발견했을 때만 기존 테스트를 수정한다.

> 💡 소프트웨어를 개발할 때 목적이 '기능 추가'인지, '리팩터링'인지 명확히 구분하여 작업한다. 
>
> '기능 추가' 모자와 '리팩터링' 모자, 항상 내가 쓰고 있는 모자가 무엇인지와 그에 따른 작업 방식의 차이를 분명하게 인식해야 한다.

<br />

## 2.3 리팩터링하는 이유

+ 리팩터링이 소프트웨어의 모든 문제점을 해결하는 만병통치약은 아니지만, 코드를 건강한 상태로 유지하는 데 도와주는 약임은 분명하다. 리팩터링은 다양한 용도로 활용할 수 있고, 또 반드시 그래야 하는 도구다.

#### 리팩터링하면 소프트웨어 설계가 좋아진다.

+ 코드만 봐서는 설계를 파악하기 어려워 구조를 충분히 이해하지 못한 채 코드를 수정하다 보면 기반 구조가 무너지기 쉽다. 코드만으로 설계를 파악하기 어려울수록 설계를 유지하기 어렵고, 따라서 설계가 부패되는 속도는 더욱 빨라진다. 규칙적인 리팩터링은 코드의 구조를 지탱해준다.
+ 중복 코드 제거는 설계 개선 작업의 중요한 한 축을 차지한다. 설계가 나쁘면 코드가 길어지기 쉽고, 중복 코드가 나타난다. 코드량을 줄인다고 시스템이 빨라지는 것은 아니지만, 이해해야 할 코드량이 줄어 실수 없이 수정하기 쉬워지므로 수정하는 데 드는 노력이 훨씬 줄어든다. 유사한 동작의 코드가 산재하면, 한 부분만 살짝 바꿔서는 예상대로 동작하지 않을 수 있다. 중복 코드를 제거하면 모든 코드가 언제나 고유한 일을 수행함을 보장할 수 있고, 이는 바람직한 설계의 핵심이다. 

#### 리팩터링하면 소프트웨어를 이해하기 쉬워진다.

+ 프로그래밍은 여러 면에서 컴퓨터와 대화하는 것과 같다. 컴퓨터에게 시키려는 일과 이를 표현한 코드의 차이를 최대한 줄여야 한다. 프로그래밍은 결국 내가 원하는 바를 정확히 표현하는 일이다.
+ 문제는 프로그램을 동작시키는 데만 신경 쓰다 보면, 나중에 그 코드를 다룰 개발자를 배려하지 못한다는 데 있다. 리팩터링은 코드가 더 잘 읽히게 도와준다. 잘 동작하지만 이상적인 구조는 아닌 코드가 있다면, 리팩터링해보자. 코드의 목적이 더 잘드러나게, 내 의도를 더 명확하게 전달할 수 있도록 개선할 수 있다. 그리고 이는 단지 다른 사람을 배려하기 위한 것이 아니다. 사실 그 다른 사람은 바로 나 자신일 때가 많다. 기억할 필요가 있는 것들은 최대한 코드에 담고 작성한 코드를 최대한 머릿 속에서 지워, 기억 용량을 초과하였을 때 문제가 생기지 않도록 한다.

#### 리팩터링하면 버그를 쉽게 찾을 수 있다.

+ 코드를 이해하기 쉽다는 말은 버그를 찾기 쉽다는 말이기도 하다. 리팩터링을 하면 코드가 하는 일을 깊이 파악하게 되면서 새로 깨달은 것을 곧바로 코드에 반영할 수 있다. 구조를 명확하게 다듬기 전에 이럴 것이라고 추측하던 것들이, 버그를 지나칠 수 없을 정도까지 명확해진다.
+ 이 사실은 켄트 백의 말을 떠올리게 해준다. "난 뛰어난 프로그래머가 아니에요. 단지 뛰어난 습관을 지닌 괜찮은 프로그래머일 뿐이에요."

#### 리팩터링하면 프로그래밍 속도를 높일 수 있다.

+ 지금까지 제시한 장점을 한 마디로 정리하면 다음과 같다. "리팩터링하면 코드 개발 속도를 높일 수 있다."
+ 내부 설계와 가독성이 개선되고 버그가 줄어든다는 점은 모두 품질 향상에 직결된다. 하지만 리팩터링하는 데 시간이 드니 전체 개발 속도는 떨어질까봐 걱정할 수 있다. 하지만 개발은 초기 단계를 벗어나면, 이후에는 새로운 기능을 기존 코드 베이스에 녹여낼 방법을 찾고 기능을 추가하였을 때 생기는 버그를 해결하는 데에 시간을 많이 쓰게 된다. 내부 설계 개선 없이 패치에 패치가 덧붙으며 동작을 파악하기가 어려워진 경우, 기능 추가 속도가 계속 떨어져 처음부터 새로 개발하는 편이 낫겠다고 생각하는 지경에 이른다. 
+ 그러나 내부 설계가 잘 된 소프트웨어는 새로운 기능을 추가할 지점과 어떻게 고칠지를 쉽게 찾을 수 있다. 모듈화가 잘 되어 있다면 전체 중 작은 일부만 이해하면 된다. 코드가 명확하므로 버그를 만들 가능성도 줄고, 만들더라도 디버깅하기가 훨씬 쉽다. 내부 품질이 뛰어난 코드베이스는 새 기능 구축을 돕는 견고한 토대가 된다.
+ 내부 설계에 심혈을 기울이면 소프트웨어의 지구력이 높아져 빠르게 개발할 수 있는 상태를 더 오래 지속할 수 있다. 저자는 이 효과를 설계 지구력 가설(Design Stamina Hypothesis)이라고 부른다.

<br />

