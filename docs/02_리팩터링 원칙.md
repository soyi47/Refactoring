# Chapter 02. 리팩터링 원칙

> 🌱 2장에서는 리팩터링 전반에 적용되는 원칙 몇 가지를 이야기한다.

<br />

## 2.1 리팩터링 정의

+ **리팩터링 refactoring**

  + [명사] 소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 **내부 구조를 변경하는 기법**
  + (-하다) [동사] 소프트웨어의 겉보기 동작은 그대로 유지한 채, **여러 가지 리팩터링 기법을 적용해서 소프트웨어를 재구성하다.**

+ 위에서 제시한 정의를 따르면, **특정한 방식에 따라 코드를 정리하는 것만이 리팩터링**이다. 리팩터링은 **동작을 보존하는 작은 단계를 거쳐 코드를 수정하고, 이 단계들을 순차적으로 연결하여 코드 상에 큰 변화를 만들어내는 일**이다. 개별 리팩터링은 아주 작을 수도 있고, 여러 개가 합쳐진 모습일 수도 있다. 리팩터링하는 동안에는 코드가 항상 정상 작동하므로 전체 작업이 끝나지 않아도 언제든 중단할 수 있다.

  > 💡 누군가 "리팩터링하다가 코드가 깨져서 며칠이나 고생했다"라고 한다면, 십중팔구 리팩터링한 것이 아니다.

+ **코드를 정리하거나 구조를 바꾸는 모든 작업**을 포괄적으로 "**재구성 restructuring**"이라는 용어로 표현한다. 리팩터링은 재구성 중 특수한 하나의 형태로 본다. 작업 단계를 체계적으로 잘게 나누는 방법을 통해, 무엇보다 디버깅하는 데 시간을 뺏기지 않아 작업을 더 빨리 처리할 수 있게 된다.

+ "**겉보기 동작 observable behavior**"을 유지한다는 것은, 리팩터링 하기 전과 후의 **코드가 사용자 관점에서 달라지는 점 없이 똑같이 동작해야 한다**는 의미다.

+ 리팩터링과 성능 최적화

  + 리팩터링과 성능 최적화는 둘 다 코드를 변경하지만 **전반적인 기능을 그대로 유지한다는 점에서 유사**하다. 둘은 **목적에서 차이**를 보인다.
  + 리팩터링의 목적 : 이해하고 수정하기 쉬운 코드로 만드는 것. 성능은 좋아질 수도, 나빠질 수도 있다.
  + 성능 최적화의 목적 : 속도 개선. 목표 성능에 도달하는 과정에서 코드는 더 복잡하고 어려워질 수 있다.

<br />

## 2.2 두 개의 모자

+ **'기능 추가'** 모자 : 기존 코드는 절대 건드리지 않고 **새 기능을 추가하기만 한다.**
+ **'리팩터링'** 모자 : 기능 추가는 절대 하지 않고, **오로지 코드 재구성에 전념**한다. 테스트도 새로 만들지 않는다. 부득이 인터페이스를 변경하거나, 놓친 테스트 케이스를 발견했을 때만 기존 테스트를 수정한다.

> 💡 소프트웨어를 개발할 때 목적이 '기능 추가'인지, '리팩터링'인지 명확히 구분하여 작업한다. 
>
> '기능 추가' 모자와 '리팩터링' 모자, 항상 내가 쓰고 있는 모자가 무엇인지와 그에 따른 작업 방식의 차이를 분명하게 인식해야 한다.

<br />

