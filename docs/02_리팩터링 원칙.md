# Chapter 02. 리팩터링 원칙

> 🌱 2장에서는 리팩터링 전반에 적용되는 원칙 몇 가지를 이야기한다.

<br />

## 2.1 리팩터링 정의

+ **리팩터링 refactoring**

  + [명사] 소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 **내부 구조를 변경하는 기법**
  + (-하다) [동사] 소프트웨어의 겉보기 동작은 그대로 유지한 채, **여러 가지 리팩터링 기법을 적용해서 소프트웨어를 재구성하다.**

+ 위에서 제시한 정의를 따르면, **특정한 방식에 따라 코드를 정리하는 것만이 리팩터링**이다. 리팩터링은 **동작을 보존하는 작은 단계를 거쳐 코드를 수정하고, 이 단계들을 순차적으로 연결하여 코드 상에 큰 변화를 만들어내는 일**이다. 개별 리팩터링은 아주 작을 수도 있고, 여러 개가 합쳐진 모습일 수도 있다. 리팩터링하는 동안에는 코드가 항상 정상 작동하므로 전체 작업이 끝나지 않아도 언제든 중단할 수 있다.

  > 💡 누군가 "리팩터링하다가 코드가 깨져서 며칠이나 고생했다"라고 한다면, 십중팔구 리팩터링한 것이 아니다.

+ **코드를 정리하거나 구조를 바꾸는 모든 작업**을 포괄적으로 "**재구성 restructuring**"이라는 용어로 표현한다. 리팩터링은 재구성 중 특수한 하나의 형태로 본다. 작업 단계를 체계적으로 잘게 나누는 방법을 통해, 무엇보다 디버깅하는 데 시간을 뺏기지 않아 작업을 더 빨리 처리할 수 있게 된다.

+ "**겉보기 동작 observable behavior**"을 유지한다는 것은, 리팩터링 하기 전과 후의 **코드가 사용자 관점에서 달라지는 점 없이 똑같이 동작해야 한다**는 의미다.

+ 리팩터링과 성능 최적화

  + 리팩터링과 성능 최적화는 둘 다 코드를 변경하지만 **전반적인 기능을 그대로 유지한다는 점에서 유사**하다. 둘은 **목적에서 차이**를 보인다.
  + 리팩터링의 목적 : 이해하고 수정하기 쉬운 코드로 만드는 것. 성능은 좋아질 수도, 나빠질 수도 있다.
  + 성능 최적화의 목적 : 속도 개선. 목표 성능에 도달하는 과정에서 코드는 더 복잡하고 어려워질 수 있다.

<br />

## 2.2 두 개의 모자

+ **'기능 추가'** 모자 : 기존 코드는 절대 건드리지 않고 **새 기능을 추가하기만 한다.**
+ **'리팩터링'** 모자 : 기능 추가는 절대 하지 않고, **오로지 코드 재구성에 전념**한다. 테스트도 새로 만들지 않는다. 부득이 인터페이스를 변경하거나, 놓친 테스트 케이스를 발견했을 때만 기존 테스트를 수정한다.

> 💡 소프트웨어를 개발할 때 목적이 '기능 추가'인지, '리팩터링'인지 명확히 구분하여 작업한다. 
>
> '기능 추가' 모자와 '리팩터링' 모자, 항상 내가 쓰고 있는 모자가 무엇인지와 그에 따른 작업 방식의 차이를 분명하게 인식해야 한다.

<br />

## 2.3 리팩터링하는 이유

+ 리팩터링이 소프트웨어의 모든 문제점을 해결하는 만병통치약은 아니지만, 코드를 건강한 상태로 유지하는 데 도와주는 약임은 분명하다. 리팩터링은 다양한 용도로 활용할 수 있고, 또 반드시 그래야 하는 도구다.

#### 리팩터링하면 소프트웨어 설계가 좋아진다.

+ 코드만 봐서는 설계를 파악하기 어려워 구조를 충분히 이해하지 못한 채 코드를 수정하다 보면 기반 구조가 무너지기 쉽다. 코드만으로 설계를 파악하기 어려울수록 설계를 유지하기 어렵고, 따라서 설계가 부패되는 속도는 더욱 빨라진다. 규칙적인 리팩터링은 코드의 구조를 지탱해준다.
+ 중복 코드 제거는 설계 개선 작업의 중요한 한 축을 차지한다. 설계가 나쁘면 코드가 길어지기 쉽고, 중복 코드가 나타난다. 코드량을 줄인다고 시스템이 빨라지는 것은 아니지만, 이해해야 할 코드량이 줄어 실수 없이 수정하기 쉬워지므로 수정하는 데 드는 노력이 훨씬 줄어든다. 유사한 동작의 코드가 산재하면, 한 부분만 살짝 바꿔서는 예상대로 동작하지 않을 수 있다. 중복 코드를 제거하면 모든 코드가 언제나 고유한 일을 수행함을 보장할 수 있고, 이는 바람직한 설계의 핵심이다. 

#### 리팩터링하면 소프트웨어를 이해하기 쉬워진다.

+ 프로그래밍은 여러 면에서 컴퓨터와 대화하는 것과 같다. 컴퓨터에게 시키려는 일과 이를 표현한 코드의 차이를 최대한 줄여야 한다. 프로그래밍은 결국 내가 원하는 바를 정확히 표현하는 일이다.
+ 문제는 프로그램을 동작시키는 데만 신경 쓰다 보면, 나중에 그 코드를 다룰 개발자를 배려하지 못한다는 데 있다. 리팩터링은 코드가 더 잘 읽히게 도와준다. 잘 동작하지만 이상적인 구조는 아닌 코드가 있다면, 리팩터링해보자. 코드의 목적이 더 잘드러나게, 내 의도를 더 명확하게 전달할 수 있도록 개선할 수 있다. 그리고 이는 단지 다른 사람을 배려하기 위한 것이 아니다. 사실 그 다른 사람은 바로 나 자신일 때가 많다. 기억할 필요가 있는 것들은 최대한 코드에 담고 작성한 코드를 최대한 머릿 속에서 지워, 기억 용량을 초과하였을 때 문제가 생기지 않도록 한다.

#### 리팩터링하면 버그를 쉽게 찾을 수 있다.

+ 코드를 이해하기 쉽다는 말은 버그를 찾기 쉽다는 말이기도 하다. 리팩터링을 하면 코드가 하는 일을 깊이 파악하게 되면서 새로 깨달은 것을 곧바로 코드에 반영할 수 있다. 구조를 명확하게 다듬기 전에 이럴 것이라고 추측하던 것들이, 버그를 지나칠 수 없을 정도까지 명확해진다.
+ 이 사실은 켄트 백의 말을 떠올리게 해준다. "난 뛰어난 프로그래머가 아니에요. 단지 뛰어난 습관을 지닌 괜찮은 프로그래머일 뿐이에요."

#### 리팩터링하면 프로그래밍 속도를 높일 수 있다.

+ 지금까지 제시한 장점을 한 마디로 정리하면 다음과 같다. "리팩터링하면 코드 개발 속도를 높일 수 있다."
+ 내부 설계와 가독성이 개선되고 버그가 줄어든다는 점은 모두 품질 향상에 직결된다. 하지만 리팩터링하는 데 시간이 드니 전체 개발 속도는 떨어질까봐 걱정할 수 있다. 하지만 개발은 초기 단계를 벗어나면, 이후에는 새로운 기능을 기존 코드 베이스에 녹여낼 방법을 찾고 기능을 추가하였을 때 생기는 버그를 해결하는 데에 시간을 많이 쓰게 된다. 내부 설계 개선 없이 패치에 패치가 덧붙으며 동작을 파악하기가 어려워진 경우, 기능 추가 속도가 계속 떨어져 처음부터 새로 개발하는 편이 낫겠다고 생각하는 지경에 이른다. 
+ 그러나 내부 설계가 잘 된 소프트웨어는 새로운 기능을 추가할 지점과 어떻게 고칠지를 쉽게 찾을 수 있다. 모듈화가 잘 되어 있다면 전체 중 작은 일부만 이해하면 된다. 코드가 명확하므로 버그를 만들 가능성도 줄고, 만들더라도 디버깅하기가 훨씬 쉽다. 내부 품질이 뛰어난 코드베이스는 새 기능 구축을 돕는 견고한 토대가 된다.
+ 내부 설계에 심혈을 기울이면 소프트웨어의 지구력이 높아져 빠르게 개발할 수 있는 상태를 더 오래 지속할 수 있다. 저자는 이 효과를 설계 지구력 가설(Design Stamina Hypothesis)이라고 부른다.

<br />

## 2.4 언제 리팩터링해야 할까?

#### 3의 법칙
+ 돈 로버츠(Don Roberts)가 저자에게 제시한 가이드
> 1. 처음에는 그냥 한다.
> 2. 비슷한 일을 두 번째로 하게 되면, 중복이 생겼어도 일단 계속 진행한다.
> 3. 비슷한 일을 세 번째 하게 되면 리팩터링한다.

#### 준비를 위한 리팩터링: 기능을 쉽게 추가하게 만들기
+ 리팩터링하기 가장 좋은 시점은 기능을 새로 추가하기 직전이다. 코드를 살펴보며 구조를 살작 바꾸면 다른 작업을 하기 훨씬 쉬워질 만한 부분을 찾는다. 예로, 요구사항을 거의 만족하지만 리터럴 값 몇 개가 방해되는 함수가 있다고 가정하자. 함수를 복사해서 해당 값만 수정하여 중복 코드를 만드는 경우, 중복 부분을 변경할 일이 생기면 원래 코드와 복제한 코드 모두를 수정해야하고, 중복 코드가 어디 있는지 일일이 찾아야 한다. 이럴 때 리팩터링을 진행한다. 함수 매개변수화하기를 적용하고, 함수에 필요한 매개변수를 지정하여 호출하도록 수정한다.
	
	> 지금 위치에서 동쪽으로 100km 이동하려는데 그 사이를 숲이 가로막고 있따면, 둘러가더라도 20km 북쪽의 고속도로를 타는 편이 세 배나 빠를 수 있다. 다들 "직진!"을 외치더라도, 때로는 "지도를 보고 가장 빠른 경로를 찾아보자"고 말할 줄 알아야 한다. 준비를 위한 리팩터링이 바로 이런 역할을 한다. - 제시카 커(Jessica Kert)

+ 버그를 잡을 때도 마찬가지. 오류를 일으키는 모드가 여러 곳에 복제되어 있다면, 한 곳으로 합치는 편이 작업하기 훨씬 편하다. 준비를 위한 리팩터링으로 상황을 개선해놓으면, 버그가 수정된 상태가 오래 지속될 가능성을 높이고, 같은 곳에서 다른 버그가 발생할 가능성도 줄일 수 있다.

#### 이해를 위한 리팩터링: 코드를 이해하기 쉽게 만들기

+ 조건부 로직의 구조가 이상하지 않은지, 함수 이름을 잘못 정해서 실제로 하는 일을 파악하는 데 시간이 오래 걸리지 않는지 등 코드의 의도가 더 명확하게 드러나도록 리팩터링할 여지가 없는지 찾아보자.
+ 리팩터링하면 머리로 이해한 것을 코드에 옮겨 담을 수 있다. 그리고 수정한 코드를 테스트해보면 내 생각이 맞았는지 확인할 수 있다. 내가 이해한 것을 코드에 반영해두면 더 오래 보존할 수 있을 뿐만 아니라, 동료들도 코드의 의도를 알 수 있다.
+ 어떤 역할인지 이해된 변수는 적절한 이름으로 바꿔주고, 긴 함수를 잘게 나눈 등 이해를 위한 리팩터링을 적용하면, 코드가 깔끔하게 정리되어 전에는 보이지 않던 설계가 눈에 들어오기 시작한다. 모든 변경을 머릿속으로 시뮬레이션해볼 수 없기에, 코드를 정리하지 않았더라면 영원히 못 보고 지나쳤을지 모를 것들이다. 코드를 분석할 때 리팩터링을 해보면, 리팩터링없이는 도달하지 못했을 더 깊은 수준까지 이해하게 된다.

#### 쓰레기 줍기 리팩터링

+ 코드를 파악하는 중 비효율적으로 처리하는 코드(로직이 쓸데없이 복잡하거나, 거의 똑같은 함수 여러 개를 작성해놨거나...)를 발견할 때가 있다. 원래 하려던 작업과 관련 없는 일에 너무 많은 시간을 빼앗길 수 없고, 동시에 나중에 방해가 되도록 쓰레기를 방치하는 것도 좋지 않으므로 약간의 절충이 필요하다. 간단히 수정할 수 있는 것은 즉시 고치고, 시간이 좀 걸리는 일은 짧은 메모만 남긴 다음, 하던 일을 끝내고 나서 처리한다. 이것이 이해를 위한 리팩터링의 변형인 쓰레기 줍기 리팩터링(Litter-Pickup Refactoring)이다.

+ 리팩터링의 멋진 점은 각 작은 단계가 코드를 깨뜨리지 않는다는 사실이다. 수정하려면 몇 시간이나 걸리고 당장은 더 급한 일이 있을 수 있지만, 조금이나마 개선해두자. 코드를 훑어볼 때마다 조금씩 개선하다 보면 결국 문제가 해결될 것이며, 그 과정을 몇 달에 걸쳐 진행하더라도 그 사이 한 번도 코드가 깨지지 않기도 한다.

#### 계획된 리팩터링과 수시로 하는 리팩터링

+ 앞의 준비를 위한 리팩터링, 이해를 위한 리팩터링, 쓰레기 줍기 리팩터링은 모두 기회가 될 때만 진행한다. 리팩터링 일정을 따로 잡지 않고, 프로그래밍 과정에 자연스럽게 녹여, 기능을 추가하거나 버그를 잡는 동안 리팩터링도 함께 한다. 리팩터링은 프로그래밍과 구분되는 별개의 활동이 아니다. 기능을 추가할 때든 버그를 잡을 때는, 리팩터링은 당장의 문제뿐 아니라 앞으로의 작업에도 도움을 준다.

+ >  보기 싫은 코드를 보면 리팩터링해야 함은 당연하지만, 잘 작성된 코드 역시 수많은 리팩터링을 거쳐야 한다.

  리팩터링을 과거의 실수를 바로잡거나 보기 싫은 코드를 정리하는 작업이라고 오해하기 쉬우나, 잘 작성된 코드 역시 수많은 리팩터링을 거쳐야 한다. 어제는 적합했던 기준이 오늘의 다른 작업에는 맞지 않을 수 있다. 상황이 변해 기준을 변경해야 할 때, 코드가 이미 깔끔하다면 리팩터링하기가 더 쉽다.

+ > 무언가 수정하려 할 때는 먼저 수정하기 쉽게 정돈하고(단, 만만치 않을 수 있다) 그 다음 쉽게 수정하자. - 켄트 벡

  뛰어난 개발자는 새 기능을 추가하기 쉽도록 코드를 '수정'하는 것이 그 기능을 가장 빠르게 추가하는 길일 수 있음을 안다. 소프트웨어 개발을 끝이 있는 작업으로 볼 수 없다. 새 기능이 필요할 때마다 소프트웨어는 이를 반영하기 위해 수정된다. 이때 새로 작성해 넣는 코드보다 기존 코드 수정량이 더 큰 경우다 대체로 많다.

+ 계획된 리팩터링이 무조건 나쁘다는 것은 아니다. 리팩터링에 소홀했다면 따로 시간을 내서 코드베이스를 개선할 필요가 있다. 그러나 정기적으로 리팩터링하더라도 어떤 문제는 다수의 인력이 달려들어야 할 정도로 심각해질 수 있다. 이런 이유로 계획된 리팩터링을 하게 되는 일은 최소한으로 줄이고, 리팩터링의 대부분은 드러나지 않게, 기회가 될 때마다 해야 한다.

+ 리팩터링 커밋과 기능 추가 커밋을 분리해야 한다는 견해에 저자는 완전히 동의하지는 않는다. 리팩터링을 기능 추가와 밀접한 경우가 너무나 많기 때문에 굳이 나누는 것은 시간 낭비일 수 있다. 또 두 커밋을 나누면 리팩터링을 하게 된 맥락 정보가 사라져 왜 그렇게 수정했는지 이해하기 어려워진다. 리팩터링 커밋을 분리하는 것이 무조건 좋은 것은 아님을 명심하고, 적합한 방식을 실험을 통해 찾아내야 한다.

#### 오래 걸리는 리팩터링

+ 대부분의 리팩터링을 몇 분, 길어야 몇 시간 안에 끝난다. 그러나 팀 전체가 참여하여 몇 주가 거리는 대규모 리팩터링(라이브러리 교체, 일부 코드를 컴포넌트로 추출, 쌓여온 의존성 제거...)도 있다. 이런 상황에 처하더라도 팀 전체가 리팩터링에 매달리기보다, 주어진 문제를 몇 주에 걸쳐 조금씩 해결하는 편이 효과적일 때가 많다. 누구든 리팩터링할 코드와 관련한 작업을 하게 될 때마다 원하는 방향으로 조금씩 개선하는 방식이다.

#### 코드 리뷰에 리팩터링 활용하기

+ 코드 리뷰는 개발 팀 전체에 지식을 전파하는 데 좋다. 코드 리뷰를 통한 서로의 기여가 일을 더욱 편하게 만들어 준다.
  + 경험이 더 많은 개발자의 노하우를 더 적은 개발자에게 전수할 수 있다.
  + 대규모 시스템의 다양한 측면을 많은 사람들이 이해하는 데 도움이 된다.
  + 내 눈에는 명확한 코드가 다른 사람에게는 그렇지 않을 수 있다. 깔끔한 코드를 작성하는 데에도 중요하다.
  + 다른 사람의 아이디어를 얻을 수 있다.
+ 코드 리뷰에 리팩터링을 접목하는 가장 좋은 방법은 작성자와 나란히 앉아서 코드를 훑어가면서 리팩터링하는 것이다. 이렇게 하면 자연스럽게 프로그래밍 과정 안에 지속적인 코드 리뷰가 녹아 있는 짝 프로그래밍(pair programming)이 된다.

#### 관리자에게는 뭐라고 말해야 할까?

+ 관리자와 고객인 '리팩터링은 누적된 오류를 잡는 일이거나, 가치 있는 기능을 만들어내지 못하는 작업'이라고 오해하는 경우가 있다. 리팩터링 일정을 몇 주씩 잡는 개발팀이나 어설픈 재구성 작업으로 코드베이스를 오히려 망가뜨리는 모습을 보면 이들의 불신은 증폭된다. 기술을 모르는 관리자와 고객인 경우, 코드베이스의 건강 상태가 생산성에 미치는 영향을 모른다. 이런 상황에서는 이들에게 "리팩터링한다고 말하지 말라"고 조언하겠다. 관리자가 기술에 정통하고 설계 지구력 가설도 잘 이해하고 있다면, 리팩터링의 필요성을 쉽게 설득할 수 있고, 오히려 관리자가 리팩터링을 권장하고 살펴보기도 하므로 리팩터링이 부족할 가능성은 거의 없다.
+ 소프트웨어 개발자는 프로다. 프로 개발자의 역할을 효과적인 소프트웨어를 최대한 빨리 만드는 것이다. 새 함수를 추가하려는 데 현재 설계가 적합하지 않거나 버그를 수정하기 위해 현재 설계를 이해해야 한다면, 리팩터링부터 하는 편이 가장 빠르다. 관리자는 일정을 최우선으로 여기므로 최대한 빨리 끝내는 방향으로 진행하기를 원한다. 그 구체적인 방법은 개발자가 판단해야 한다. 주어진 임무는 새로운 기능을 빠르게 구현하는 것이고, 가장 빠른 방법은 리팩터링이다.

#### 리팩터링하지 말아야 할 때

+ 지저분한 코드가 있어도, 굳이 수정할 필요가 없다면 내버려둔다. 내부 동작을 이해해야 할 시점에 리팩터링해야 효과를 제대로 볼 수 있다.
+ 리팩터링보다 처음부터 새로 작성하는 것이 쉬울 때도 리팩터링하지 않는다. 직접 해보기 전에는 어느 쪽이 쉬운지 확실히 알 수 없을때가 많기 때문에 이 결정을 내리기는 쉽지 않다. 이를 잘 결정하려면 뛰어난 판단력과 경험이 뒷받침돼야 한다.

<br />

## 2.5 리팩터링 시 고려할 문제

+ 무언가를 언제 어디에 적용할지 판단하려면 손익을 제대로 이해해야 한다. 리팩터링이 많은 팀에서 적극적으로 도입해야 할 중요한 기법이라 믿지만, 딸려 오는 문제로 엄연히 있기에, 이런 문제가 언제 발생하고 어떻게 대처해야 할지를 반드시 알고 있어야 한다.

#### 새 기능 개발 속도 저하

+ > 리팩터링의 궁극적인 목적은 개발 속도를 높여서, 더 적은 노력으로 더 많은 가치를 창출하는 것이다.

	하지만 리팩터링으로 인해 진행이 느려진다고 생각하는 사람들이 여전히 많고, 이 점이 실전에서 리팩터링을 제대로 적용하는 데 가장 큰 걸림돌인 것 같다. 그렇다해도 상황에 맞게 조율해야 한다. 리팩터링이 필요해 보이지만, 새 기능이 아주 작아 기능 추가부터 하고 싶은 상황에서는, 프로 개발자로서 가진 경험을 잘 발휘해서 결정한다.
	
	+ 준비를 위한 리팩터링을 하면 변경을 훨씬 쉽게 할 수 있다고 확신한다. 그래서 기능 추가가 편해지겠다 싶은 리팩터링이라면 주저하지 않고 리팩터링부터 한다. 반면 직접 건드릴 일이 거의 없거나, 불편한 정도가 그리 심하지 않다거나, 때로는 어떻게 개선해야 할지 확실히 떠오르지 않아서 리팩터링을 미루기도 한다.
	
+ 경험담을 들어보면 리팩터링이 과도한 경우보다 거의 하지 않는 경우가 훨씬 많다. 다시 말해 대부분은 리팩터링을 더 자주 하도록 노력해야 한다. 건강한 코드의 위력을 충분히 경험해보아야, 코드베이스가 건강할 때와 허약할 때의 생산성 차이를 체감할 수 있다. 코드베이스가 건강하면 기존 코드를 새로운 방식으로 조합하기 쉬워 복잡한 기능을 더 빨리 추가할 수 있다.

+ 리팩터링 할지 말지를 판단하는 능력은 수년에 걸친 경험을 통해 서서히 형성된다. 리더는 리팩터링 경험이 부족한 이들이 이런 능력을 빠르게 갖추도록 개발 과정에서 많이 이끌어줘야 한다.

+ **사람들이 빠지기 쉬운 가장 위험한 오류는 리팩터링을 '클린 코드 clean code'나 '바람직한 엔지니어링 습관'처럼 도덕적인 이유로 정당화하는 것**이다. **리팩터링의 본질**은 코드베이스를 예쁘게 꾸미는 데 있는 것이 아니라, **오로지 경제적인 이유**로 하는 것이다. 개발 기간을 단축하고, 기능 추가 시간을 줄이고, 버그 수정 시간을 줄이기 위한 것임을, **리팩터링하도록 이끄는 동력은 어디까지나 경제적인 효과에 있음을 명심**해야 한다.

#### 코드 소유권

+ 리팩터링하다 보면 모듈의 내부뿐 아니라 시스템의 다른 부분과 연동하는 방식에도 영향을 주는 경우가 많다. 함수를 호출하는 코드의 소유자가 다른 팀이라서 나에게는 쓰기 권한이 없을 수 있고, 바꾸려는 함수가 고객에게 API로 제공된 것일 수도 있다. 이런 함수는  클라이언트가 사용하는 '공개된 인터페이스'에 속한다. 코드 소유권이 나뉘어 있으면 리팩터링에 방해가 된다. 클라이언트에 영향을 주지 않고서는 원하는 형태로 변경할 수 없기 때문이다. 이때 리팩터링을 통해 개선하려면 제약이 따른다. 예로, 함수 이름을 변경할 때는 기존 함수도 그대로 유지하되, 함수 본문에서 새 함수를 호출하도록 수정한다. 인터페이스는 복잡해져도 클라이언트에 영향을 주지 않으려면 어쩔 수 없다. 기존 인터페이스를 폐기 대상(deprecated)으로 지정하고 이후 삭제할 수도 있지만, 영원히 남겨둬야 할 수도 있다.
+ 코드 소유권이 작은 단위로 나뉘면 코드베이스에서 곧바로 수정하면 훨씬 간단할 일을 계속 인터페이스를 관리하느라 시달리는 결과를 초래한다. 저자가 선호하는 방식은 **코드 소유권을 팀에 두어, 팀원이라면 누구나 팀이 소유한 코드를 수정할 수 있게 하는 것**이다. **프로그래머마다 각자 책임지는 영역이 있을 수는 있지만, 이는 자신이 맡은 영역의 변경 사항을 관리하라는 의미지, 다른 사람이 수정하지 못하게 막으라는 뜻이 아니다.**

#### 브랜치

+ **흔히 사용되는 팀 단위 작업 방식으로 기능 브랜치 방식**이 사용된다. 팀원마다 브랜치를 하나씩 맡아서 작업하다가 결과물이 쌓이면 마스터 브랜치에 통합하여 공유하는 것이다. 이를 선호하는 사람들은 **작업이 끝나지 않은 코드가 섞이지 않고, 기능이 추가될 때마다 버전을 명확히 나눌 수 있고, 문제가 생기면 이전 상태로 쉽게 되돌릴 수 있어 좋다**고 한다. 

  하지만 기능 브랜치 방식에는 **단점**이 있다. **독립 브랜치로 작업하는 기간이 길어질수록 작업 결과를 마스터로 통합하기 어려워진다.** 누군가 개인 브랜치에서 작업한 내용을 마스터에 통합하기 전까지는 다른 사람이 그 내용을 볼 수 없다. **통합 후 마스터에서 달라진 내용을 내 브랜치에서 머지하려면 상당한 노력이 들 수 있다.** 최신 버전 관리 시스템은 복잡한 변경 사항을 텍스트 수준에서 머지하는 데는 매우 뛰어나지만, 코드의 의미를 이해하지는 못한다. 예로, 의미가 변한 부분을 처리하기가 만만치 않다. 함수 이름이 바뀌는 정도는 가볍게 통합하지만, 다른 브랜치에서 함수 호출 코드를 추가했는데, 내 브랜치에서는 그 함수의 이름을 변경했다면 프로그램은 동작하지 않게 된다.

  + 머지와 통합을 명확히 구분한다. **마스터를 브랜치로 '머지'하는 작업은 내 브랜치만 바뀌고 마스터는 그대로인 단방향 작업**이다. **'통합'은 마스터를 개인 브랜치고 가져와서(pull) 작업한 결과를 다시 마스터에 올리는(push) 방식으로, 마스터와 브랜치가 모두 변경되는 양방향 처리**를 의미한다.

+ 기능별 브랜치들이 독립적으로 개발되는 기간이 길수록, 위처럼 머지가 복잡해지는 문제가 기하급수적으로 늘어난다. **브랜치를 자주 통합할 수 있다면 문제가 발생할 가능성을 크게 줄일 수 있다.** 때문에 **기능별 브랜치의 통합 주기**를 2~3일 단위로 **짧게 관리할 것**을 주장하는 사람이 많고, 저자와 같은 사람들은 더 짧아야 한다고 주장한다. 이 방식을 **지속적 통합(CI, Continuous Integration) 또는 트렁크 기반 개발(TBD, Trunk-Based Development)**이라 한다. CI에 따르면 **모든 팀원이 하루에 최소 한번은 마스터와 통합**한다. 이러면 다른 브랜치와 차이가 크게 벌어지는 브랜치가 없어져 머지 복잡도를 상당히 낮출 수 있다. 단순 기능별 브랜치가 가져오는 리팩터링 부담은 너무 크기 때문에, **CI를 완벽히 적용하지는 못하더라도 통합 주기만큼은 최대한 짧게 잡아야 한다.**

  + CI를 적용하기 위해서는, 마스터를 건강하게 유지하고, 거대한 기능을 잘개 쪼개는 법을 배우고, 각 기능을 끌 수 있는 기능 토글(feature toggle 또는 기능 플래그 feature flag)를 적용하여 완료되지 않은 기능이 시스템 전체를 망치지 않도록 해야 한다.
  + CI는 리팩터링과 궁합이 아주 좋다. 켄트 벡이 **CI + 리팩터링**의 **익스트림 프로그래밍(XP, eXtreme Programming)**을 만든 이유도 두 기법의 궁합이 잘 맞기 때문이다. 리팩터링을 하다 보면 코드베이스 전반에 걸쳐 자잘하게 수정하는 부분이 많을 때가 있다. 이런 경우 머지 과정에서 의미 충돌이 생기기 쉽고, 특히 기능별 브랜치 방식에서는 도저히 리팩터링할 수 없을 정도의 심각한 머지 문제가 발생하기 쉽다.

#### 테스팅

+ **리팩터링의 두드러진 특성은 겉보기 동작은 똑같이 유지된다는 것**이고, 절차를 지켜 제대로 리팩터링하면 동작이 깨지지 않아야 한다. **실수가 생겨 동작이 깨졌을 때는 재빨리 해결**하면 문제가 되지 않는다. 여기서 **핵심은 오류를 재빨리 잡는 데** 있고, 실제로 그렇게 하려면 코드의 다양한 측면을 검사하는 테스트 스위트(test suite)가 필요하다. 그리고 이를 빠르게 실행할 수 있어야 수시로 테스트하는 데 부담이 없다. **즉, 리팩터링하기 위해서는 대부분의 경우 자가 테스트 코드(self-testing code), 스스로 성공과 실패를 판단하는 테스트를 마련**해야 한다.
+ **자가 테스트의 효과**는 상당하다. 테스트가 실패했고 테스트 주기가 짧다면, 가장 최근 통과한 버전과 단 몇 줄만 비교하면 되고, 문제를 일으킨 부분은 그 몇 줄 안에 있기 때문에 **버그를 쉽게 찾을 수 있다.** 실수로 만든 버그를 빠르게 찾아서 제거할 수 있기 때문에, **새 기능 추가를 훨씬 안전하게 진행하는데 도움**이 된다. 또, **리팩터링 과정에서 버그가 생길 위험이 크다는 불안감을 해소**하는데 도움이 된다. 
+ 자가 테스트 코드는 통합 과정에서 발생하는 의미 충돌을 잡는 방식으로 활용할 수 있어, CI와도 밀접하게 연관된다. CI에 통합된 테스트는 XP의 권장사항이자 **지속적 배포(CD, Continous Delivery)의 핵심**이다.
+ 테스트 문제는 다른 방식으로도 해결할 수 있다. 만약, 뛰어나고 안전한 자동 리팩터링 기능을 제공하는 환경이라면 굳이 테스트하지 않아도 오류가 생기지 않음을 확신할 수 있다. 이러한 생각을 바탕으로 안전하다고 검증된 몇 가지 리팩터링 기법만 조합해서 사용하자는 흐름이 등장했다. 각 단계는 신중히 진행되야 하고, 구체적인 방법은 언어마다 달라진다.

#### 레거시 코드

+ 물려 받은 레거시 코드(legacy code)는 대체로 복잡하고 테스트도 제대로 갖춰지지 않은 것이 많으며, 무엇보다 다른 사람이 작성한 것이다. **레거시 시스템을 파악할 때 리팩터링이 굉장히 도움**이 되는데, **대규모 레거시 시스템을 테스트 코드 없이 명료하게 리팩터링하기는 어렵다. 문제의 정답은 테스트 보강이다.** 간단해 보이지만 해보면 생각보다 훨씬 까다로울 것이다. 테스트를 염두에 두고 설계한 시스템만 쉽게 테스트할 수 있고, 애초에 그런 시스템이라면 테스트를 갖추고 있어 이런 걱정을 할 일이 없다.
+ 쉽게 해결할 방법은 없다. <레거시 코드 활용 전략> (에이콘, 2018)에 나온 지침을 충실히 따르자. 주요 내용을 표현하면 **'프로그램에서 테스트를 추가할 틈새를 찾아 시스템을 테스트해야 한다'**는 것이다. 테스트 없이 진행하기 때문에 상당히 위험하지만 문제 해결을 위해선 감내해야 한다. 이와 같은 난감한 상황에서 빠져나올 수 있는 더 쉬운 방법은 없다. 처음부터 자가 테스트 코드를 그토록 강조한 이유가 바로 이 때문이다.
+ 레거시 코드를 단번에 리팩터링하는 데는 낙관적이지 않다. **서로 관련된 부분끼리 나눠서 하나씩 공략하자.** 규모가 크다면 자주 보는 부분을 더 많이 리팩터링한다. **코드의 한 부분을 훑고 넘어갈 때마다 예전보다 조금이라도 개선하려고 노력**한다. 

#### 데이터베이스

+ 데이터베이스와 관련해서는, **진화형 데이트베이스 설계(evolutionary database design)와 데이터베이스 리팩터링 기법**이 널리 적용되고 있다. 핵심은 커다란 변경들을 쉽게 조합하고 다룰 수 있는 데이터 마이그레이션 스크립트를 작성하고, 접근 코드와 데이터베이스 스키마에 대한 구조적 변경을 이 스크립트로 처리하게끔 통합하는 데 있다. 다른 리팩터링과 마찬가지로 이 기법도 전체 과정을 작고 독립된 단계들로 쪼개는 것이 핵심이다.
+ **데이터베이스 리팩터링은 프로덕션 환경에 여러 단계로 나눠서 릴리스하는 것이 대체로 좋다**는 점에서 다른 리팩터링과 다르다. 이렇게 하면 프로덕션 환경에서 문제가 생겼을 때 변경을 되돌리기 쉽다. 이렇게 변경하는 방식은 **병렬 수정(parallel change 또는 팽창-수축 expand-contract)의 일반적인 예**다. 필드 이름을 바꿀 때를 예로 들면,
  1. 첫 번째 커밋에서는 새로운 데이터베이스 필드를 추가만 하고 사용하지 않는다.
  2. 그 다음, 기존 필드와 새 필드를 동시에 업데이트하도록 설정한다.
  3. 데이터베이스를 읽는 클라이언트들을 새 필드를 사용하는 버전으로 조금씩 교체한다.
  4. 과정에서 발생하는 버그를 해결하며 클라이언트 교체 작업이 모두 끝났을 때, 더이상 필요 없어진 예전 필드를 삭제한다.

<br />

## 2.6 리팩터링, 아키텍처, 애그니(YAGNI)

+ 코딩을 시작하기 전에 소프트웨어 설계와 아키텍처를 어느정도, 심지어 거의 완료해야 한다고 배워왔다. 하지만 **코딩 전 아키텍처를 확정지을 때 대표적인 문제는, 요구사항을 사전에 모두 파악해야 한다는 것이다. 막상 해보면 실현할 수 없는 목표일 때가 많다.** 실제로 사용해보고 확인하고 나서야 원하는 바를 알게 되는 경우가 허다하다. **리팩터링은 소프트웨어 아키텍처를 바라보는 관점을 완전히 바꿔놓았다.** 수년 동안 운영되던 소프트웨어라도 아키텍처를 유연하게 대폭 변경할 수 있게 되었다. **리팩터링이 아키텍처에 미치는 실질적인 효과는 요구사항 변화에 자연스럽게 대응하도록 코드 베이스를 잘 설계해준다**는 데 있다.

+ **리팩터링을 활용하여 향후 변경에 유연하게 대처**할 수 있다. 어느 부분에 유연성이 필요하고 어떻게 변화에 대응할 수 있을지 추측하지 않고, **현재까지 파악한 요구사항만을 해결하는 소프트웨어를 구축**한다. 단, 이 요구를 멋지게 해결하도록 설계한다. 복잡도에 지장을 주지 않는 매커니즘은 마음껏 추가한다. **복잡도를 높일 수 있는 유연성 메커니즘은 예상되는 변경을 미리 반영하는 리팩터링을 미루면 훨씬 힘들어진다는 확신이 들 때만 미리 추가**한다.
  + 유연성 메커니즘(flexibility mechanism) - 예상 시나리오에 대응하기 위한 매개변수를 미리 추가해둔다면, 이때 매개변수가 바로 유연성 메커니즘이다. 생각나는 대로 유연성 메커니즘을 추가하면 당장의 쓰임에 비해 너무 복잡해지고, 이후 새로운 메커니즈믈 추가하기가 더 어려워지기도 한다. 당초 예상과 요구사항이 달라지거나, 메커니즘 자체의 결함이 있는 등 메커니즘을 잘못 구현할 수도 있다. 그렇다보니 오히려 유연성 메커니즘이 변화에 대응하는 능력을 떨어뜨릴 때가 대부분이다.
+ 위와 같은 설계 방식을 **간결한 설계(simple design), 점진적 설계(incremental design), YAGNI(you aren't going to need it, 애그니)** 등으로 부른다. YAGNI는 아키텍처를 고려하지 말라는 의미가 아니다. XP의 원칙 중 하나로 **'당장 필요한 기능만으로 최대한 간결하게 만들라'**는 의미다. 실제로 필요할 것 같아 미리 구현해둔 기능이 결국 전혀 쓰이지 않거나 요구 사항을 제대로 반영하지 못해 오히려 수정하기 더 어려워지는 경우가 많다.
+ **YAGNI는 아키텍처와 설계를 개발 프로세스에 녹이는 방식**이며 **리팩터링의 뒷받침 없이는 효과를 볼 수 없다.** YAGNI가 선제적인 아키텍처에 완전히 소홀해도 된다는 의미는 아니다. 미리 생각해둔 아키텍처로 시간이 절약되는 경우도 얼마든지 있으나, 개발을 진행하면서 문제에 대한 이해도가 높아졌을 때 처리하는 쪽이 훨씬 낫다는 것이다. 이런 경향은 **진화형 아키텍처(evolutionary architecture)** 원칙이 발전하는 계기가 되었다. 진화형 아키텍처는 아키텍처 관련 결정을 시간을 두고 반복해 내릴 수 있다는 장점을 활용하는 패턴과 실천법을 추구한다.

<br />

## 2.7 리팩터링과 소프트웨어 개발 프로세스

1. 팀의 개발 실천법에 따라 리팩터링의 효과가 크게 달라진다. 리팩터링이 퍼지기 시작한 것은 XP에 도입됐기 때문이다. 최초의 애자일 소프트웨어 방법론 중 하나로 등장한 **XP**의 두드러진 특징은 **지속적 통합, 자가 테스트 코드, 리팩터링 등의 개성 강하면서 상호 의존하는 기법들을 하나로 묶은 프로세스**라는 점이다. 자가 **테스트 코드와 리팩터링 둘을 묶어서 테스트 주도 개발(Test-Driven Developement, TDD)**이라 한다. 프로그래밍 중 발생한 오류를 확실히 걸러내는 테스트를 자동으로 수행할 수 있도록하는 자가 테스트 코드. 각 팀원이 다른 사람의 작업을 방해하지 않으면서 언제든지 리팩터링할 수 있도록 하는 지속적 통합 CI. **자가 테스트 코드, 지속적 통합, 리팩터링 세 기법의 조합은 서로 강력한 상승효과**를 발휘한다.

2. 자가 테스트 코드, 지속적 통합, 리팩터링의 세 가지 실천법을 적용한다면, YAGNI 설계 방식으로 개발을 진행할 수 있다. 리팩터링과 YAGNI 또한 서로 긍정적인 영향을 준다. 이상의 **세 가지 실천법은 YAGNI의 토대**다. 동시에, 수많은 유연성 메커니즘을 갖출 시스템보다 단순한 시스템이 변경하기 훨씬 쉽기 때문에, YAGNI로 인해 리팩터링을 더욱 쉽게 할 수 있게 된다. 이 **모두를 잘 조화시키면 요구사항 변화에 재빠르게 대응하고 안정적인 선순환 구조를 코드베이스에 심을 수 있다.**
3. 위와 같이 **핵심 실천법을 갖추었을 때, 애자일의 다른 요소가 주는 이점을 취할 수 있게 된다.** 지속적 배포를 통해 수정사항을 하루에도 여러 차례 배포할 수 있게 되고, 비즈니스 요구에 맞춰 배포 일정을 계획할 수 있다. 위험 요소를 줄이며, 고치는 데 오래 걸리는 버그의 수를 줄이고 소프트웨어 신뢰성을 높일 수 있다. 견고한 기술적 토대를 기반으로 좋은 아이디어를 프로덕션 코드에 반영하는 시간을 크게 단축하여 고객에게 더 나은 서비스를 제공할 수 있다.

<br />

