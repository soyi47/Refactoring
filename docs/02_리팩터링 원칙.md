# Chapter 02. 리팩터링 원칙

> 🌱 2장에서는 리팩터링 전반에 적용되는 원칙 몇 가지를 이야기한다.

<br />

## 2.1 리팩터링 정의

+ **리팩터링 refactoring**

  + [명사] 소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 **내부 구조를 변경하는 기법**
  + (-하다) [동사] 소프트웨어의 겉보기 동작은 그대로 유지한 채, **여러 가지 리팩터링 기법을 적용해서 소프트웨어를 재구성하다.**

+ 위에서 제시한 정의를 따르면, **특정한 방식에 따라 코드를 정리하는 것만이 리팩터링**이다. 리팩터링은 **동작을 보존하는 작은 단계를 거쳐 코드를 수정하고, 이 단계들을 순차적으로 연결하여 코드 상에 큰 변화를 만들어내는 일**이다. 개별 리팩터링은 아주 작을 수도 있고, 여러 개가 합쳐진 모습일 수도 있다. 리팩터링하는 동안에는 코드가 항상 정상 작동하므로 전체 작업이 끝나지 않아도 언제든 중단할 수 있다.

  > 💡 누군가 "리팩터링하다가 코드가 깨져서 며칠이나 고생했다"라고 한다면, 십중팔구 리팩터링한 것이 아니다.

+ **코드를 정리하거나 구조를 바꾸는 모든 작업**을 포괄적으로 "**재구성 restructuring**"이라는 용어로 표현한다. 리팩터링은 재구성 중 특수한 하나의 형태로 본다. 작업 단계를 체계적으로 잘게 나누는 방법을 통해, 무엇보다 디버깅하는 데 시간을 뺏기지 않아 작업을 더 빨리 처리할 수 있게 된다.

+ "**겉보기 동작 observable behavior**"을 유지한다는 것은, 리팩터링 하기 전과 후의 **코드가 사용자 관점에서 달라지는 점 없이 똑같이 동작해야 한다**는 의미다.

+ 리팩터링과 성능 최적화

  + 리팩터링과 성능 최적화는 둘 다 코드를 변경하지만 **전반적인 기능을 그대로 유지한다는 점에서 유사**하다. 둘은 **목적에서 차이**를 보인다.
  + 리팩터링의 목적 : 이해하고 수정하기 쉬운 코드로 만드는 것. 성능은 좋아질 수도, 나빠질 수도 있다.
  + 성능 최적화의 목적 : 속도 개선. 목표 성능에 도달하는 과정에서 코드는 더 복잡하고 어려워질 수 있다.

<br />

## 2.2 두 개의 모자

+ **'기능 추가'** 모자 : 기존 코드는 절대 건드리지 않고 **새 기능을 추가하기만 한다.**
+ **'리팩터링'** 모자 : 기능 추가는 절대 하지 않고, **오로지 코드 재구성에 전념**한다. 테스트도 새로 만들지 않는다. 부득이 인터페이스를 변경하거나, 놓친 테스트 케이스를 발견했을 때만 기존 테스트를 수정한다.

> 💡 소프트웨어를 개발할 때 목적이 '기능 추가'인지, '리팩터링'인지 명확히 구분하여 작업한다. 
>
> '기능 추가' 모자와 '리팩터링' 모자, 항상 내가 쓰고 있는 모자가 무엇인지와 그에 따른 작업 방식의 차이를 분명하게 인식해야 한다.

<br />

## 2.3 리팩터링하는 이유

+ 리팩터링이 소프트웨어의 모든 문제점을 해결하는 만병통치약은 아니지만, 코드를 건강한 상태로 유지하는 데 도와주는 약임은 분명하다. 리팩터링은 다양한 용도로 활용할 수 있고, 또 반드시 그래야 하는 도구다.

#### 리팩터링하면 소프트웨어 설계가 좋아진다.

+ 코드만 봐서는 설계를 파악하기 어려워 구조를 충분히 이해하지 못한 채 코드를 수정하다 보면 기반 구조가 무너지기 쉽다. 코드만으로 설계를 파악하기 어려울수록 설계를 유지하기 어렵고, 따라서 설계가 부패되는 속도는 더욱 빨라진다. 규칙적인 리팩터링은 코드의 구조를 지탱해준다.
+ 중복 코드 제거는 설계 개선 작업의 중요한 한 축을 차지한다. 설계가 나쁘면 코드가 길어지기 쉽고, 중복 코드가 나타난다. 코드량을 줄인다고 시스템이 빨라지는 것은 아니지만, 이해해야 할 코드량이 줄어 실수 없이 수정하기 쉬워지므로 수정하는 데 드는 노력이 훨씬 줄어든다. 유사한 동작의 코드가 산재하면, 한 부분만 살짝 바꿔서는 예상대로 동작하지 않을 수 있다. 중복 코드를 제거하면 모든 코드가 언제나 고유한 일을 수행함을 보장할 수 있고, 이는 바람직한 설계의 핵심이다. 

#### 리팩터링하면 소프트웨어를 이해하기 쉬워진다.

+ 프로그래밍은 여러 면에서 컴퓨터와 대화하는 것과 같다. 컴퓨터에게 시키려는 일과 이를 표현한 코드의 차이를 최대한 줄여야 한다. 프로그래밍은 결국 내가 원하는 바를 정확히 표현하는 일이다.
+ 문제는 프로그램을 동작시키는 데만 신경 쓰다 보면, 나중에 그 코드를 다룰 개발자를 배려하지 못한다는 데 있다. 리팩터링은 코드가 더 잘 읽히게 도와준다. 잘 동작하지만 이상적인 구조는 아닌 코드가 있다면, 리팩터링해보자. 코드의 목적이 더 잘드러나게, 내 의도를 더 명확하게 전달할 수 있도록 개선할 수 있다. 그리고 이는 단지 다른 사람을 배려하기 위한 것이 아니다. 사실 그 다른 사람은 바로 나 자신일 때가 많다. 기억할 필요가 있는 것들은 최대한 코드에 담고 작성한 코드를 최대한 머릿 속에서 지워, 기억 용량을 초과하였을 때 문제가 생기지 않도록 한다.

#### 리팩터링하면 버그를 쉽게 찾을 수 있다.

+ 코드를 이해하기 쉽다는 말은 버그를 찾기 쉽다는 말이기도 하다. 리팩터링을 하면 코드가 하는 일을 깊이 파악하게 되면서 새로 깨달은 것을 곧바로 코드에 반영할 수 있다. 구조를 명확하게 다듬기 전에 이럴 것이라고 추측하던 것들이, 버그를 지나칠 수 없을 정도까지 명확해진다.
+ 이 사실은 켄트 백의 말을 떠올리게 해준다. "난 뛰어난 프로그래머가 아니에요. 단지 뛰어난 습관을 지닌 괜찮은 프로그래머일 뿐이에요."

#### 리팩터링하면 프로그래밍 속도를 높일 수 있다.

+ 지금까지 제시한 장점을 한 마디로 정리하면 다음과 같다. "리팩터링하면 코드 개발 속도를 높일 수 있다."
+ 내부 설계와 가독성이 개선되고 버그가 줄어든다는 점은 모두 품질 향상에 직결된다. 하지만 리팩터링하는 데 시간이 드니 전체 개발 속도는 떨어질까봐 걱정할 수 있다. 하지만 개발은 초기 단계를 벗어나면, 이후에는 새로운 기능을 기존 코드 베이스에 녹여낼 방법을 찾고 기능을 추가하였을 때 생기는 버그를 해결하는 데에 시간을 많이 쓰게 된다. 내부 설계 개선 없이 패치에 패치가 덧붙으며 동작을 파악하기가 어려워진 경우, 기능 추가 속도가 계속 떨어져 처음부터 새로 개발하는 편이 낫겠다고 생각하는 지경에 이른다. 
+ 그러나 내부 설계가 잘 된 소프트웨어는 새로운 기능을 추가할 지점과 어떻게 고칠지를 쉽게 찾을 수 있다. 모듈화가 잘 되어 있다면 전체 중 작은 일부만 이해하면 된다. 코드가 명확하므로 버그를 만들 가능성도 줄고, 만들더라도 디버깅하기가 훨씬 쉽다. 내부 품질이 뛰어난 코드베이스는 새 기능 구축을 돕는 견고한 토대가 된다.
+ 내부 설계에 심혈을 기울이면 소프트웨어의 지구력이 높아져 빠르게 개발할 수 있는 상태를 더 오래 지속할 수 있다. 저자는 이 효과를 설계 지구력 가설(Design Stamina Hypothesis)이라고 부른다.

<br />

## 2.4 언제 리팩터링해야 할까?

#### 3의 법칙
+ 돈 로버츠(Don Roberts)가 저자에게 제시한 가이드
> 1. 처음에는 그냥 한다.
> 2. 비슷한 일을 두 번째로 하게 되면, 중복이 생겼어도 일단 계속 진행한다.
> 3. 비슷한 일을 세 번째 하게 되면 리팩터링한다.

#### 준비를 위한 리팩터링: 기능을 쉽게 추가하게 만들기
+ 리팩터링하기 가장 좋은 시점은 기능을 새로 추가하기 직전이다. 코드를 살펴보며 구조를 살작 바꾸면 다른 작업을 하기 훨씬 쉬워질 만한 부분을 찾는다. 예로, 요구사항을 거의 만족하지만 리터럴 값 몇 개가 방해되는 함수가 있다고 가정하자. 함수를 복사해서 해당 값만 수정하여 중복 코드를 만드는 경우, 중복 부분을 변경할 일이 생기면 원래 코드와 복제한 코드 모두를 수정해야하고, 중복 코드가 어디 있는지 일일이 찾아야 한다. 이럴 때 리팩터링을 진행한다. 함수 매개변수화하기를 적용하고, 함수에 필요한 매개변수를 지정하여 호출하도록 수정한다.
	
	> 지금 위치에서 동쪽으로 100km 이동하려는데 그 사이를 숲이 가로막고 있따면, 둘러가더라도 20km 북쪽의 고속도로를 타는 편이 세 배나 빠를 수 있다. 다들 "직진!"을 외치더라도, 때로는 "지도를 보고 가장 빠른 경로를 찾아보자"고 말할 줄 알아야 한다. 준비를 위한 리팩터링이 바로 이런 역할을 한다. - 제시카 커(Jessica Kert)

+ 버그를 잡을 때도 마찬가지. 오류를 일으키는 모드가 여러 곳에 복제되어 있다면, 한 곳으로 합치는 편이 작업하기 훨씬 편하다. 준비를 위한 리팩터링으로 상황을 개선해놓으면, 버그가 수정된 상태가 오래 지속될 가능성을 높이고, 같은 곳에서 다른 버그가 발생할 가능성도 줄일 수 있다.

#### 이해를 위한 리팩터링: 코드를 이해하기 쉽게 만들기

+ 조건부 로직의 구조가 이상하지 않은지, 함수 이름을 잘못 정해서 실제로 하는 일을 파악하는 데 시간이 오래 걸리지 않는지 등 코드의 의도가 더 명확하게 드러나도록 리팩터링할 여지가 없는지 찾아보자.
+ 리팩터링하면 머리로 이해한 것을 코드에 옮겨 담을 수 있다. 그리고 수정한 코드를 테스트해보면 내 생각이 맞았는지 확인할 수 있다. 내가 이해한 것을 코드에 반영해두면 더 오래 보존할 수 있을 뿐만 아니라, 동료들도 코드의 의도를 알 수 있다.
+ 어떤 역할인지 이해된 변수는 적절한 이름으로 바꿔주고, 긴 함수를 잘게 나눈 등 이해를 위한 리팩터링을 적용하면, 코드가 깔끔하게 정리되어 전에는 보이지 않던 설계가 눈에 들어오기 시작한다. 모든 변경을 머릿속으로 시뮬레이션해볼 수 없기에, 코드를 정리하지 않았더라면 영원히 못 보고 지나쳤을지 모를 것들이다. 코드를 분석할 때 리팩터링을 해보면, 리팩터링없이는 도달하지 못했을 더 깊은 수준까지 이해하게 된다.

#### 쓰레기 줍기 리팩터링

+ 코드를 파악하는 중 비효율적으로 처리하는 코드(로직이 쓸데없이 복잡하거나, 거의 똑같은 함수 여러 개를 작성해놨거나...)를 발견할 때가 있다. 원래 하려던 작업과 관련 없는 일에 너무 많은 시간을 빼앗길 수 없고, 동시에 나중에 방해가 되도록 쓰레기를 방치하는 것도 좋지 않으므로 약간의 절충이 필요하다. 간단히 수정할 수 있는 것은 즉시 고치고, 시간이 좀 걸리는 일은 짧은 메모만 남긴 다음, 하던 일을 끝내고 나서 처리한다. 이것이 이해를 위한 리팩터링의 변형인 쓰레기 줍기 리팩터링(Litter-Pickup Refactoring)이다.
+ 리팩터링의 멋진 점은 각 작은 단계가 코드를 깨뜨리지 않는다는 사실이다. 수정하려면 몇 시간이나 걸리고 당장은 더 급한 일이 있을 수 있지만, 조금이나마 개선해두자. 코드를 훑어볼 때마다 조금씩 개선하다 보면 결국 문제가 해결될 것이며, 그 과정을 몇 달에 걸쳐 진행하더라도 그 사이 한 번도 코드가 깨지지 않기도 한다.

  #### 계획된 리팩터링과 수시로 하는 리팩터링

+ 앞의 준비를 위한 리팩터링, 이해를 위한 리팩터링, 쓰레기 줍기 리팩터링은 모두 기회가 될 때만 진행한다. 리팩터링 일정을 따로 잡지 않고, 프로그래밍 과정에 자연스럽게 녹여, 기능을 추가하거나 버그를 잡는 동안 리팩터링도 함께 한다. 리팩터링은 프로그래밍과 구분되는 별개의 활동이 아니다. 기능을 추가할 때든 버그를 잡을 때는, 리팩터링은 당장의 문제뿐 아니라 앞으로의 작업에도 도움을 준다.

+ >  보기 싫은 코드를 보면 리팩터링해야 함은 당연하지만, 잘 작성된 코드 역시 수많은 리팩터링을 거쳐야 한다.

  리팩터링을 과거의 실수를 바로잡거나 보기 싫은 코드를 정리하는 작업이라고 오해하기 쉬우나, 잘 작성된 코드 역시 수많은 리팩터링을 거쳐야 한다. 어제는 적합했던 기준이 오늘의 다른 작업에는 맞지 않을 수 있다. 상황이 변해 기준을 변경해야 할 때, 코드가 이미 깔끔하다면 리팩터링하기가 더 쉽다.

+ > 무언가 수정하려 할 때는 먼저 수정하기 쉽게 정돈하고(단, 만만치 않을 수 있다) 그 다음 쉽게 수정하자. - 켄트 벡

  뛰어난 개발자는 새 기능을 추가하기 쉽도록 코드를 '수정'하는 것이 그 기능을 가장 빠르게 추가하는 길일 수 있음을 안다. 소프트웨어 개발을 끝이 있는 작업으로 볼 수 없다. 새 기능이 필요할 때마다 소프트웨어는 이를 반영하기 위해 수정된다. 이때 새로 작성해 넣는 코드보다 기존 코드 수정량이 더 큰 경우다 대체로 많다.

+ 계획된 리팩터링이 무조건 나쁘다는 것은 아니다. 리팩터링에 소홀했다면 따로 시간을 내서 코드베이스를 개선할 필요가 있다. 그러나 정기적으로 리팩터링하더라도 어떤 문제는 다수의 인력이 달려들어야 할 정도로 심각해질 수 있다. 이런 이유로 계획된 리팩터링을 하게 되는 일은 최소한으로 줄이고, 리팩터링의 대부분은 드러나지 않게, 기회가 될 때마다 해야 한다.

+ 리팩터링 커밋과 기능 추가 커밋을 분리해야 한다는 견해에 저자는 완전히 동의하지는 않는다. 리팩터링을 기능 추가와 밀접한 경우가 너무나 많기 때문에 굳이 나누는 것은 시간 낭비일 수 있다. 또 두 커밋을 나누면 리팩터링을 하게 된 맥락 정보가 사라져 왜 그렇게 수정했는지 이해하기 어려워진다. 리팩터링 커밋을 분리하는 것이 무조건 좋은 것은 아님을 명심하고, 적합한 방식을 실험을 통해 찾아내야 한다.

#### 오래 걸리는 리팩터링

+ 대부분의 리팩터링을 몇 분, 길어야 몇 시간 안에 끝난다. 그러나 팀 전체가 참여하여 몇 주가 거리는 대규모 리팩터링(라이브러리 교체, 일부 코드를 컴포넌트로 추출, 쌓여온 의존성 제거...)도 있다. 이런 상황에 처하더라도 팀 전체가 리팩터링에 매달리기보다, 주어진 문제를 몇 주에 걸쳐 조금씩 해결하는 편이 효과적일 때가 많다. 누구든 리팩터링할 코드와 관련한 작업을 하게 될 때마다 원하는 방향으로 조금씩 개선하는 방식이다.

#### 코드 리뷰에 리팩터링 활용하기

+ 코드 리뷰는 개발 팀 전체에 지식을 전파하는 데 좋다. 코드 리뷰를 통한 서로의 기여가 일을 더욱 편하게 만들어 준다.
  + 경험이 더 많은 개발자의 노하우를 더 적은 개발자에게 전수할 수 있다.
  + 대규모 시스템의 다양한 측면을 많은 사람들이 이해하는 데 도움이 된다.
  + 내 눈에는 명확한 코드가 다른 사람에게는 그렇지 않을 수 있다. 깔끔한 코드를 작성하는 데에도 중요하다.
  + 다른 사람의 아이디어를 얻을 수 있다.
+ 코드 리뷰에 리팩터링을 접목하는 가장 좋은 방법은 작성자와 나란히 앉아서 코드를 훑어가면서 리팩터링하는 것이다. 이렇게 하면 자연스럽게 프로그래밍 과정 안에 지속적인 코드 리뷰가 녹아 있는 짝 프로그래밍(pair programming)이 된다.

#### 관리자에게는 뭐라고 말해야 할까?

+ 관리자와 고객인 '리팩터링은 누적된 오류를 잡는 일이거나, 가치 있는 기능을 만들어내지 못하는 작업'이라고 오해하는 경우가 있다. 리팩터링 일정을 몇 주씩 잡는 개발팀이나 어설픈 재구성 작업으로 코드베이스를 오히려 망가뜨리는 모습을 보면 이들의 불신은 증폭된다. 기술을 모르는 관리자와 고객인 경우, 코드베이스의 건강 상태가 생산성에 미치는 영향을 모른다. 이런 상황에서는 이들에게 "리팩터링한다고 말하지 말라"고 조언하겠다. 관리자가 기술에 정통하고 설계 지구력 가설도 잘 이해하고 있다면, 리팩터링의 필요성을 쉽게 설득할 수 있고, 오히려 관리자가 리팩터링을 권장하고 살펴보기도 하므로 리팩터링이 부족할 가능성은 거의 없다.
+ 소프트웨어 개발자는 프로다. 프로 개발자의 역할을 효과적인 소프트웨어를 최대한 빨리 만드는 것이다. 새 함수를 추가하려는 데 현재 설계가 적합하지 않거나 버그를 수정하기 위해 현재 설계를 이해해야 한다면, 리팩터링부터 하는 편이 가장 빠르다. 관리자는 일정을 최우선으로 여기므로 최대한 빨리 끝내는 방향으로 진행하기를 원한다. 그 구체적인 방법은 개발자가 판단해야 한다. 주어진 임무는 새로운 기능을 빠르게 구현하는 것이고, 가장 빠른 방법은 리팩터링이다.

#### 리팩터링하지 말아야 할 때

+ 지저분한 코드가 있어도, 굳이 수정할 필요가 없다면 내버려둔다. 내부 동작을 이해해야 할 시점에 리팩터링해야 효과를 제대로 볼 수 있다.
+ 리팩터링보다 처음부터 새로 작성하는 것이 쉬울 때도 리팩터링하지 않는다. 직접 해보기 전에는 어느 쪽이 쉬운지 확실히 알 수 없을때가 많기 때문에 이 결정을 내리기는 쉽지 않다. 이를 잘 결정하려면 뛰어난 판단력과 경험이 뒷받침돼야 한다.

<br />

